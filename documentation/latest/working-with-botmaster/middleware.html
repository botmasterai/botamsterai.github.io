
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Middleware Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.2">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-versions/plugin.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="incoming-update.html" />
    
    
    <link rel="prev" href="bot-object.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../getting-started/">
            
                <a href="../getting-started/">
            
                    
                    Getting started
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../getting-started/installation.html">
            
                <a href="../getting-started/installation.html">
            
                    
                    Installation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../getting-started/quickstart.html">
            
                <a href="../getting-started/quickstart.html">
            
                    
                    Quickstart
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../getting-started/webhooks.html">
            
                <a href="../getting-started/webhooks.html">
            
                    
                    Webhooks
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../messaging-platforms.html">
            
                <a href="../messaging-platforms.html">
            
                    
                    Messaging Platforms
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="./">
            
                <a href="./">
            
                    
                    Working With Botmaster
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="bot-object.html">
            
                <a href="bot-object.html">
            
                    
                    Bot object
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.4.2" data-path="middleware.html">
            
                <a href="middleware.html">
            
                    
                    Middleware
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="incoming-update.html">
            
                <a href="incoming-update.html">
            
                    
                    Incoming update
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="outgoing-message.html">
            
                <a href="outgoing-message.html">
            
                    
                    Outgoing message
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="botmaster-object.html">
            
                <a href="botmaster-object.html">
            
                    
                    Botmaster object
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.6" data-path="writing-your-own-bot-class.html">
            
                <a href="writing-your-own-bot-class.html">
            
                    
                    Writing your own bot class
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../middlewares/">
            
                <a href="../middlewares/">
            
                    
                    Middlewares
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../middlewares/fulfill.html">
            
                <a href="../middlewares/fulfill.html">
            
                    
                    fulfill
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../tutorials/">
            
                <a href="../tutorials/">
            
                    
                    Tutorials
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../tutorials/using-fulfill.html">
            
                <a href="../tutorials/using-fulfill.html">
            
                    
                    Using Fulfill
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../tutorials/watson-conversation.html">
            
                <a href="../tutorials/watson-conversation.html">
            
                    
                    Watson Conversation
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../articles/">
            
                <a href="../articles/">
            
                    
                    Articles
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../articles/frameworks-comparison.html">
            
                <a href="../articles/frameworks-comparison.html">
            
                    
                    Framworks comparison
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../api-reference/">
            
                <a href="../api-reference/">
            
                    
                    API reference
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="../api-reference/botmaster.html">
            
                <a href="../api-reference/botmaster.html">
            
                    
                    Botmaster
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="../api-reference/base-bot.html">
            
                <a href="../api-reference/base-bot.html">
            
                    
                    BaseBot
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../api-reference/outgoing-message.html">
            
                <a href="../api-reference/outgoing-message.html">
            
                    
                    OutgoingMessage
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../changelog.html">
            
                <a href="../changelog.html">
            
                    
                    Changelog
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Middleware</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="middleware">Middleware</h1>
<p>If you&apos;ve gone through the <a href="../gettings-started/quickstart.md">quickstart</a> guide, you&apos;ve actually already used middleware (well incoming middleware in this case). We do so in the &quot;Acting on updates&quot; section.</p>
<p>Middleware in Botmaster is designed to work similarly to  what you would expect 
in an <a href="http://expressjs.com/" target="_blank">express.js</a> app. I.e. almost all your code will reside in them.</p>
<p>Because Botmaster is a chatbot framework and not a web app framework, we go on and define two different types of middleware: <code>incoming</code> and <code>outgoing</code> middleware.</p>
<ul>
<li><p><a href="#incoming-middleware">Incoming middleware</a> gets called in order of declaration whenever a valid update from one of the bots added to botmaster (using <code>botmaster.addBot()</code>) is received.</p>
</li>
<li><p><a href="#outgoing-middleware">Outgoing middleware</a> gets called in order of declaration whenever you send a message using one of the bot&apos;s sendMessage methods.</p>
</li>
</ul>
<p>Both middleware types get added to their respective &quot;middleware stack&quot; by using botmaster&apos;s <code>use</code> method. Another helper method <code>useWrapped</code> can be used to add middleware. But we&apos;ll talk about that further down. A description of both methods can be found at the end of this document. For now, let&apos;s jump into examples:</p>
<h2 id="incoming-middleware">Incoming middleware</h2>
<p>As mentioned briefly above, <code>incoming</code> middleware in Botmaster is similar to what you would have in express middleware and can be used similarly. They are all called in order of declaration upon receiving an update.</p>
<h3 id="basic-incoming-middleware-example">Basic incoming middleware example</h3>
<p>Here is a very simple example of how one would go on and use <code>incoming</code> middleware:</p>
<pre><code class="lang-js"><span class="hljs-comment">// middleware that uses next (standard middleware you might be acquainted with)</span>
botmaster.use({
  type: <span class="hljs-string">&apos;incoming&apos;</span>,
  name: <span class="hljs-string">&apos;add-weather-to-update&apos;</span>,
  controller: (bot, update, next) =&gt; {
    <span class="hljs-comment">// assumed here that some weather API is queried to get that weatherInformation</span>
    update.weather = {
      temperature: <span class="hljs-number">23</span>,
      unit: <span class="hljs-string">&apos;celcius&apos;</span>,
    }
    next(); <span class="hljs-comment">// next needs to be called if your controller does not return a promise</span>
  }
});

<span class="hljs-comment">// middleware that returns an explicit promise</span>
botmaster.use({
  type: <span class="hljs-string">&apos;incoming&apos;</span>,
  name: <span class="hljs-string">&apos;add-user-info-to-update&apos;</span>,
  controller: (bot, update) =&gt; {
    <span class="hljs-comment">// update.weather will exist here</span>
    <span class="hljs-keyword">if</span> (bot.retrievesUserInfo) {
      <span class="hljs-keyword">return</span> bot.getUserInfo(update.sender.id).then((userInfo) =&gt; {
        update.userInfo = userInfo;
      })
    }

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve();
  }
});

<span class="hljs-comment">// middleware that uses async-await because we are using node7 with the async-await</span>
<span class="hljs-comment">// harmony flag or a transpiler like Babel.</span>

botmaster.use({
  type: <span class="hljs-string">&apos;incoming&apos;</span>,
  name: <span class="hljs-string">&apos;reply-to-user&apos;</span>,
  controller: <span class="hljs-keyword">async</span> (bot, update) =&gt; {
    <span class="hljs-keyword">let</span> text;
    <span class="hljs-keyword">if</span> (update.weather.temperature &gt; <span class="hljs-number">17</span>) {
      text = <span class="hljs-string">&apos;the weather is warm&apos;</span>;
    } <span class="hljs-keyword">else</span> {
      text = <span class="hljs-string">&apos;the weather is cool&apos;</span>;
    }

    <span class="hljs-keyword">if</span> (update.userInfo) {
      text += <span class="hljs-string">` <span class="hljs-subst">${update.userInfo.first_name}</span>`</span>;
    }

    <span class="hljs-keyword">const</span> body = <span class="hljs-keyword">await</span> bot.reply(update, text);
    <span class="hljs-comment">// do stuff with the body object</span>
  }
});
</code></pre>
<p>This is a very basic example. But hopefully, it gets the message through of how you can use <code>incoming</code> middleware. Here we see three ways to use middleware. All three are valid. I&apos;ll briefly address the three ways here:</p>
<ol>
<li><p>Using <code>next</code> to go to the next middleware function declared in the stack. This is the most common way middleware functions have handed over control to the next middleware in the stack. Once your middleware function is entered, you do some things and then when you&apos;re ready, you call next(). It is handy to use middleware in this way whenever your middleware makes use of callback based apis or if it&apos;s synchronous in nature.</p>
</li>
<li><p>Returning a <code>Promise</code>. Another way to hand over control to the next middleware function in the stack in Botmaster is to return a Promise. Whenever the promise resolves, control will be handed down to the next middleware function in the stack. In our example, we return the promise from <code>getUserInfo</code> if the bot class can retrieve user info. Otherwise, we return a promise that resolves straight away.</p>
</li>
<li><p>Returning Promises is great. But it gets better when you start leveraging the use of async-await functions which are already supported in Node7+ (by using the <code>--harmony-async-await</code> flag). Or you can also use Babel or another transpiler to use them. Not how in this function we don&apos;t have to return anything at the end. This is because using async will wrap our function with a Promise that will resolve naturally when it runs its course. Also, using await anywhere within the function on any function that returns a promise will just pause until the promise resolves. That is what we do when we do: <code>const body = await bot.reply(update, text);</code>. The middleware won&apos;t go to the next one, because it is waiting for the reply function&apos;s promise to resolve. Using async-await with Botmaster middleware will soon be the preferred way to write middleware as it allows you to write synchronous looking code that just goes to the next middleware function whenever the function returns (or runs its course)</p>
</li>
</ol>
<h3 id="basic-incoming-middleware-example-with-structure">Basic incoming middleware example with structure</h3>
<p>In practice, your middleware code will really live within separate files that you would &quot;require&quot; within your main &quot;app.js&quot; file. That means that the previous example will have a tree structure similar to the following:</p>
<pre><code>&#x251C;&#x2500;&#x2500; app.js
&#x2514;&#x2500;&#x2500; middleware
    &#x251C;&#x2500;&#x2500; incoming
    &#x2502;   &#x251C;&#x2500;&#x2500; weather.js
    &#x2502;   &#x251C;&#x2500;&#x2500; user_info.js
    &#x2502;   &#x251C;&#x2500;&#x2500; reply.js
    &#x2502;   &#x2514;&#x2500;&#x2500; index.js
    &#x251C;&#x2500;&#x2500; outgoing // no outgoing middleware in this example
    |    &#x2514;&#x2500;&#x2500; index.js // this will remain an empty file for now
    &#x2514;&#x2500;&#x2500; wrapped // no wrapped middleware in this example
        &#x2514;&#x2500;&#x2500; index.js // this will remain an empty file for now
</code></pre><p>This is only a suggested structure (the one I use). Feel free to come up with a different, potentially better, structure that suits you better.</p>
<p>That means that the previous example&apos;s code will probably look more like this:</p>
<p><code>middleware/incoming/weather.js</code></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> addWeatherToUpdate = {
  type: <span class="hljs-string">&apos;incoming&apos;</span>,
  name: <span class="hljs-string">&apos;add-weather-to-update&apos;</span>,
  controller: (bot, update, next) =&gt; {
    <span class="hljs-comment">// assumed here that some weather API is queried to get that weatherInformation</span>
    update.weather = {
      temperature: <span class="hljs-number">23</span>,
      unit: <span class="hljs-string">&apos;celcius&apos;</span>,
    }
    next(); <span class="hljs-comment">// next needs to be called if your controller does not return a promise</span>
  }
}

<span class="hljs-built_in">module</span>.exports = {
  addWeatherToUpdate, <span class="hljs-comment">// using shorthand here</span>
}
</code></pre>
<p><code>middleware/incoming/user_info.js</code></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> addUserInfoToUpdate = {
  type: <span class="hljs-string">&apos;incoming&apos;</span>,
  name: <span class="hljs-string">&apos;add-user-info-to-update&apos;</span>,
  controller: (bot, update) =&gt; {
    <span class="hljs-comment">// &quot;update.weather&quot; will exist here btw</span>
    <span class="hljs-keyword">if</span> (bot.retrievesUserInfo) {
      <span class="hljs-keyword">return</span> bot.getUserInfo(update.sender.id).then((userInfo) =&gt; {
        update.userInfo = userInfo;
      })
    }

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve();
  }
};

<span class="hljs-built_in">module</span>.exports = {
  addUserInfoToUpdate,
}
</code></pre>
<p><code>middleware/incoming/reply.js</code></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> replyToUser = {
  type: <span class="hljs-string">&apos;incoming&apos;</span>,
  name: <span class="hljs-string">&apos;reply-to-user&apos;</span>,
  controller: <span class="hljs-keyword">async</span> (bot, update) =&gt; {
    <span class="hljs-keyword">let</span> text;
    <span class="hljs-keyword">if</span> (update.weather.temperature &gt; <span class="hljs-number">17</span>) {
      text = <span class="hljs-string">&apos;the weather is warm&apos;</span>;
    } <span class="hljs-keyword">else</span> {
      text = <span class="hljs-string">&apos;the weather is cool&apos;</span>;
    }

    <span class="hljs-keyword">if</span> (update.userInfo) {
      text += <span class="hljs-string">` <span class="hljs-subst">${update.userInfo.first_name}</span>`</span>;
    }

    <span class="hljs-keyword">const</span> body = <span class="hljs-keyword">await</span> bot.reply(update, text);
    <span class="hljs-comment">// do stuff with the body object</span>
  }
});

<span class="hljs-built_in">module</span>.exports = {
  replyToUser, <span class="hljs-comment">// using shorthand here</span>
}
</code></pre>
<p><code>middleware/incoming/index.js</code></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> weather = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./weather&apos;</span>);
<span class="hljs-keyword">const</span> userInfo = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./userInfo&apos;</span>);
<span class="hljs-keyword">const</span> reply = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./reply&apos;</span>);

<span class="hljs-built_in">module</span>.exports = {
  weather,
  userInfo,
  reply,
};
</code></pre>
<p><code>app.js</code></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> incomingMiddleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./middleware/incoming&apos;</span>);

botmaster.use(incomingMiddleware.weather.addWeatherToUpdate);
botmaster.use(incomingMiddleware.userInfo.addUserInfoToUpdate);
botmaster.use(incomingMiddleware.reply.replyToUser);

botmaster.on(<span class="hljs-string">&apos;error&apos;</span>, (bot, err) =&gt; {
  <span class="hljs-built_in">console</span>.log(err.message);
})
</code></pre>
<p>This example is really the same as the first one.will be called only on bots of type <code>messenger</code> and the other one on all bots. We just separated it all in a reasonable file structure.</p>
<p>It should be clear by now that this reads much clearer than the previous example. Simply by reading the <code>app.js</code> file I can have an idea of what is going on in the code. Clearly, some weather information and user information is added to the <code>update</code> object. That information is then used to send customized reply to the user.</p>
<p>Do note also that we have added an error event listener on the <code>botmaster</code> object. This is done because there is no other way for us to catch errors occurring in incoming middleware. So we emit them like that so you can deal with them in this event listener.</p>
<p>Now that we&apos;ve had a look at incoming middleware, let&apos;s have a look at how outgoing middleware works.</p>
<h2 id="outgoing-middleware">Outgoing middleware</h2>
<p>similar to the <code>incoming</code> middleware, the <code>outgoing</code> middleware is called in order of declaration. However, it is called on every message object sent by you the developer. To illustrate this, here&apos;s an example:</p>
<h3 id="basic-example">Basic example</h3>
<pre><code class="lang-js">botmaster.use({
  type: <span class="hljs-string">&apos;incoming&apos;</span>,
  name: <span class="hljs-string">&apos;reply-to-user&apos;</span>,
  controller: (bot, update) =&gt; {
    <span class="hljs-keyword">return</span> bot.reply(update, <span class="hljs-string">&apos;Hello world&apos;</span>);
  }
});

botmaster.use({
  type: <span class="hljs-string">&apos;outgoing&apos;</span>,
  name: <span class="hljs-string">&apos;change-text&apos;</span>,
  controller: (bot, update, message, next) =&gt; {
    <span class="hljs-built_in">console</span>.log(message); <span class="hljs-comment">// this is a full valid messenger object/ OutgoingMessage object</span>
    message.message.text = <span class="hljs-string">&quot;Hello you!&quot;</span>;
    next();
  }
});
</code></pre>
<blockquote>
<p>The three types of middleware controller mentioned in incoming middleware are also valid with outgoing middleware. I.e. we could also have returned a Promise or does so using async-await functions.</p>
</blockquote>
<p>In this example, the incoming middleware is what you would expect if you were simply trying to reply &quot;Hello world&quot; to any message. However, if you try this out, you&apos;ll see that you get a &quot;Hello you!&quot; text message back. Indeed, our middleware, aside from printing the message object to show you what it looks like, replaces the text with &quot;Hello you&quot;.</p>
<p>This is really what you&apos;ll want to be doing within outgoing middleware. First use one of the Botmaster sendMessage helper functions to send a message, then edit it in your outgoing middleware functions. Botmaster simply creates the valid [messenger compatible] message object before hitting the outgoing middleware where you can play with this.</p>
<h3 id="basic-example-with-structure">Basic example with structure</h3>
<p>As in the incoming middleware example, in practice, your middleware code will really live within separate files that you would &quot;require: within your main &quot;app.js&quot; file. Using a structure similar to the one used in the incoming middleware example. We look at something like this:</p>
<pre><code>&#x251C;&#x2500;&#x2500; app.js
&#x2514;&#x2500;&#x2500; middleware
    &#x251C;&#x2500;&#x2500; incoming
    &#x2502;   &#x251C;&#x2500;&#x2500; reply.js
    &#x2502;   &#x2514;&#x2500;&#x2500; index.js
    &#x2514;&#x2500;&#x2500; outgoing
        &#x251C;&#x2500;&#x2500; message_transformers.js
        &#x2514;&#x2500;&#x2500; index.js
</code></pre><p>Where the code for incoming middleware looks something like this as you could expect:</p>
<p><code>middleware/incoming/reply.js</code></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> replyToUser = {
  type: <span class="hljs-string">&apos;incoming&apos;</span>,
  name: <span class="hljs-string">&apos;reply-to-user&apos;</span>,
  controller: (bot, update) =&gt; {
    <span class="hljs-keyword">return</span> bot.reply(update, <span class="hljs-string">&apos;Hello world&apos;</span>);
  }
});

<span class="hljs-built_in">module</span>.exports = {
  replyToUser,
}
</code></pre>
<p><code>middleware/incoming/index.js</code></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> reply = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./reply&apos;</span>);

<span class="hljs-built_in">module</span>.exports = {
  reply,
};
</code></pre>
<p>And the code for our outgoing middleware will look like this:</p>
<p><code>middleware/outgoing/message_transformers.js</code></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> changeText = {
  type: <span class="hljs-string">&apos;outgoing&apos;</span>,
  name: <span class="hljs-string">&apos;change-text&apos;</span>,
  controller: (bot, update, message, next) =&gt; {
    <span class="hljs-built_in">console</span>.log(message); <span class="hljs-comment">// this is a full valid messenger object/ OutgoingMessage object</span>
    message.message.text = <span class="hljs-string">&quot;Hello you!&quot;</span>;
    next();
  }
}

<span class="hljs-built_in">module</span>.exports = {
  changeText,
}
</code></pre>
<p><code>middleware/outgoing/index.js</code></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> messageTransformers = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./message_transformers&apos;</span>);

<span class="hljs-built_in">module</span>.exports = {
  messageTransformers,
};
</code></pre>
<p><code>app.js</code></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> incomingMiddleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./middleware/incoming&apos;</span>);
<span class="hljs-keyword">const</span> outgoingMiddleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./middleware/outgoing&apos;</span>);

botmaster.use(incomingMiddleware.reply.replyToUser);

botmaster.use(outgoingMiddleware.messageTransformers.changeText);
</code></pre>
<p>This might seem like slight overkill at this point because of how trivial of an example this is. But this adds clear structure to our project and when reading our app.js file we can already know what is going on. It also makes it very clear regarding what is going on if you were to add another middleware function right after the <code>changeText</code> one.</p>
<h3 id="complete-outgoing-middleware-example-with-structure">Complete outgoing middleware example with structure</h3>
<p>We first edit the reply we give to our user:</p>
<p><code>middleware/incoming/reply.js</code></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> replyToUser = {
  type: <span class="hljs-string">&apos;incoming&apos;</span>,
  name: <span class="hljs-string">&apos;reply-to-user&apos;</span>,
  controller: (bot, update) =&gt; {
    <span class="hljs-keyword">return</span> bot.sendTextCascadeTo([<span class="hljs-string">&apos;Hi there, I`m about to ask you to press buttons:&apos;</span>,
      <span class="hljs-string">&apos;Please press any of: [&quot;Button1&quot;,&quot;Button2&quot;]&apos;</span>,
      <span class="hljs-string">&apos;Thank you&apos;</span>], update.sender.id)
    .catch((err) =&gt; {
      <span class="hljs-built_in">console</span>.log(err.message);
    })
  }
});

<span class="hljs-built_in">module</span>.exports = {
  replyToUser,
}
</code></pre>
<p>Note, we are here using the Bot classes <code>sendTextCascadeTo</code> helper function to send text messages one after the other. See <a href="bot-object.html">Bot object</a>.</p>
<p>Also note that we have a catch bit there ready to catch any error that might occur within our outgoing middleware or if the platform we are sending the messages to responds with an error/4xx statusCode.</p>
<p>We now update our outgoing middleware code:</p>
<p>Taking this one step further, you can do something like the following to, say, send buttons without using the builtin <code>sendDefaultButtonMessageTo</code> method. We&apos;ll keep our structure and simply update the files to look like this:</p>
<p><code>middleware/outgoing/message_transformers.js</code></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> changeText = {
  type: <span class="hljs-string">&apos;outgoing&apos;</span>,
  name: <span class="hljs-string">&apos;change-text&apos;</span>,
  controller: (bot, update, message, next) =&gt; {
    <span class="hljs-keyword">if</span> (message.message.text === <span class="hljs-string">&apos;Thank you&apos;</span>) {
      <span class="hljs-comment">// yes, this is very arbitrary. But again, tries to drive the point of how middleware works</span>
      message.message.text = <span class="hljs-string">&apos;Thanks&apos;</span>;
    }
    next();
  }
}

<span class="hljs-keyword">const</span> addButtonsToMessage = {
  type: <span class="hljs-string">&apos;outgoing&apos;</span>,
  name: <span class="hljs-string">&apos;add-buttons-to-message&apos;</span>,
  controller: (bot, update, message) =&gt; {
    <span class="hljs-keyword">const</span> text = message.message.text;

    <span class="hljs-comment">// will match anything that looks like this: `&apos;[&quot;Button1&quot;,&quot;Button2&quot;]&apos;`</span>
    <span class="hljs-keyword">const</span> buttonsRegexObject = text.match(<span class="hljs-regexp">/&amp;\[.+]/</span>); 
    <span class="hljs-keyword">if</span> (buttonsRegexObject) {
      <span class="hljs-comment">// extract buttonTitles into an array</span>
      <span class="hljs-keyword">const</span> buttonTitles = <span class="hljs-built_in">JSON</span>.parse(buttonsRegexObject[<span class="hljs-number">0</span>].substring(<span class="hljs-number">1</span>));
      <span class="hljs-comment">// remove them from the text</span>
      <span class="hljs-keyword">const</span> message.message.text = text.replace(buttonsRegexObject[<span class="hljs-number">0</span>], <span class="hljs-string">&apos;&apos;</span>);
      <span class="hljs-comment">// adds quick reply buttons to the OutgoingMessage object.</span>
      message.addPayloadLessQuickReplies(buttonTitles);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(); <span class="hljs-comment">// could have used next here too. But driving the point that promises work too</span>
  }
}

<span class="hljs-built_in">module</span>.exports = {
  changeText, <span class="hljs-comment">// using shorthand here</span>
  addButtonsToMessage,
}
</code></pre>
<p>This simple <code>addButtonsToMessage</code> middleware simply uses regular expressions to see if the text contains any bit of text that looks anything like the following: <code>&apos;[&quot;Button1&quot;,&quot;Button2&quot;]&apos;</code>. If any such string is found, it then proceeds to remove said mentions from the text and then add a quick_replies component to your OutgoingMessage object. Note that it does so by using a helper method. These helper methods are available because Botmaster now wraps our message object in an outgoingMessage class that has helper functions to help with composing the message. See the <a href="outgoing-message.html">OutgoingMessage write-up</a> for more on that.</p>
<p>We next have a look at <code>app.js</code> that also has to be transformed:</p>
<p><code>app.js</code></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> incomingMiddleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./middleware/incoming&apos;</span>);
<span class="hljs-keyword">const</span> outgoingMiddleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./middleware/outgoing&apos;</span>);

botmaster.use(incomingMiddleware.reply.replyToUser);

botmaster.use(outgoingMiddleware.messageTransformers.changeText);
botmaster.use(outgoingMiddleware.messageTransformers.addButtonsToMessage);
</code></pre>
<p>Now this will work great. But actually, what i want to do is show the user a typing indicator right before sending every message that goes out. Because I&apos;m using a sendCascade function, namely, <code>sendTextCascadeTo</code>, the best way to do so is to do this within an outgoing middleware function. Here&apos;s how we can edit <code>app.js</code> to achieve this goal:</p>
<p><code>app.js</code></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> incomingMiddleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./middleware/incoming&apos;</span>);
<span class="hljs-keyword">const</span> outgoingMiddleware = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./middleware/outgoing&apos;</span>);

botmaster.use(incomingMiddleware.reply.replyToUser);

botmaster.use(outgoingMiddleware.messageTransformers.changeText);
botmaster.use(outgoingMiddleware.messageTransformers.addButtonsToMessage);

botmaster.use({
  type: <span class="hljs-string">&apos;outgoing&apos;</span>,
  name: <span class="hljs-string">&apos;show-indicator-before-sending-message&apos;</span>,
  controller: (bot, update, message, next) =&gt; {
    <span class="hljs-keyword">const</span> userId = message.recipient.id;

    bot.sendIsTypingMessageTo(userId, { ignoreMiddleware: <span class="hljs-literal">true</span> })

    .then(() =&gt; {
      setTimeout(() =&gt; {
        next();
      }, <span class="hljs-number">1000</span>);
    };
  },
});
</code></pre>
<p>There&apos;s a few things going on in this added bit of code here. First we make it clear again that middleware code can technically live anywhere. It would be better to have it in a separate file somewhere. But this also works. Second, We introduce the <code>ignoreMiddleware</code> option when sending a message. This will always work and simply tells Botmaster to not go through any of the middleware with this message and send it directly. This is very important as otherwise, we would be stuck in an infinite loop trying to send an &quot;is typing&quot; indicator. Second we note that we use <code>setTimeout</code> to make it look like the bot is typing for about 1 second before firing out the message by calling <code>next()</code>. Note how we don&apos;t return the <code>bot.sendIsTypingMessageTo</code> promise here, if we did, the timeout wouldn&apos;t be respected and we would get an error, as <code>next</code> cannot be called when your middleware returns a promise.</p>
<h2 id="using-skip-and-cancel">Using <strong>skip</strong> and <strong>cancel</strong></h2>
<p>Middleware comes with a few options to skip the middleware after a certain one or all together cancel sending a message (in outgoing middleware). <code>cancel</code> does the same as <code>skip</code> in incoming middleware.
Here&apos;s how you could use those.</p>
<pre><code class="lang-js">botmaster.use({
  type: <span class="hljs-string">&apos;incoming&apos;</span>,
  name: <span class="hljs-string">&apos;first-middleware&apos;</span>,
  controller: (bot, update) =&gt; {
    <span class="hljs-keyword">return</span> useSomePromiseBasedFunction(<span class="hljs-string">&apos;something&apos;</span>)
    .then((valueFromFunction) =&gt; {
      update.value = valueFromFunction;
      <span class="hljs-keyword">return</span> <span class="hljs-string">&apos;skip&apos;</span>; <span class="hljs-comment">// the returned promise will resolve with &apos;skip&apos;</span>
    })
  }
});

botmaster.use({
  type: <span class="hljs-string">&apos;incoming&apos;</span>,
  name: <span class="hljs-string">&apos;second-middleware&apos;</span>,
  controller: (bot, update, next) =&gt; {
    <span class="hljs-comment">// this will never get hit and nothing really will happen as `first middleware` does not send any message</span>
  }
});
</code></pre>
<p><code>skip</code> can also be used by outgoing middleware along with <code>cancel</code>. Here is an example of using <code>cancel</code>:</p>
<pre><code class="lang-js">botmaster.use({
  type: <span class="hljs-string">&apos;incoming&apos;</span>,
  name: <span class="hljs-string">&apos;incoming-middleware&apos;</span>,
  controller: (bot, update) =&gt; {
    <span class="hljs-keyword">return</span> bot.reply(update, <span class="hljs-string">&apos;Hey there&apos;</span>);
  }
});

botmaster.use({
  type: <span class="hljs-string">&apos;outgoing&apos;</span>,
  name: <span class="hljs-string">&apos;first-outgoing-middleware&apos;</span>,
  controller: (bot, update, message) =&gt; {
    <span class="hljs-keyword">if</span> (update.message.text === <span class="hljs-string">&apos;Hey there&apos;</span>) { <span class="hljs-comment">// for some arbitrary reason</span>
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&apos;cancel&apos;</span>);
    }
  }
});

botmaster.use({
  type: <span class="hljs-string">&apos;outgoing&apos;</span>,
  name: <span class="hljs-string">&apos;second-outgoing-middleware&apos;</span>,
  controller: (bot, update, message) =&gt; {
    <span class="hljs-comment">// this will not get hit</span>
  }
});
</code></pre>
<p>In this last example, not only will &quot;second outgoing middleware&quot; not get hit, the message will also not get sent out.
Please note, valid syntax for our &quot;first-outgoing-middleware are also the following two&quot;</p>
<pre><code class="lang-js">botmaster.use({
  type: <span class="hljs-string">&apos;outgoing&apos;</span>,
  name: <span class="hljs-string">&apos;first outgoing middleware&apos;</span>,
  controller: <span class="hljs-keyword">async</span> (bot, update, message) =&gt; { <span class="hljs-comment">// if using transpiler or node 7.x with harmony flag</span>
    <span class="hljs-keyword">if</span> (update.message.text === <span class="hljs-string">&apos;Hey there&apos;</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">&apos;cancel&apos;</span>;
    }
  }
});
</code></pre>
<p>and</p>
<pre><code class="lang-js">botmaster.use({
  type: <span class="hljs-string">&apos;outgoing&apos;</span>,
  name: <span class="hljs-string">&apos;first outgoing middleware&apos;</span>,
  controller: (bot, update, message, next) =&gt; {
    <span class="hljs-keyword">if</span> (update.message.text === <span class="hljs-string">&apos;Hey there&apos;</span>) {
      next(<span class="hljs-string">&apos;cancel&apos;</span>);
    }
  }
});
</code></pre>
<p>Now that we&apos;ve covered almost all of middleware let&apos;s quickly introduce how all this middleware was added. We made extensive use of <code>botmaster.use</code> throughout this document and this is </p>
<h4 id="here-is-the-signature-of-botmasteruse">Here is the signature of <code>botmaster.use</code></h4>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>middlewareObject</td>
<td>a valid middleware object.</td>
</tr>
</tbody>
</table>
<p>Now this might not be very helpful as what we really want to know is what this object looks like. It looks like this:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>either <code>&apos;incoming&apos;</code> or <code>&apos;outgoing&apos;</code> depending on what middleware you are setting up.</td>
</tr>
<tr>
<td>name</td>
<td>(<strong>optional</strong>) The name for this middleware. This is helpful in debugging, and you can expect it to be used in future versions of Botmaster. But it is optional. I strongly recommend naming your middleware.</td>
</tr>
<tr>
<td>controller</td>
<td>The actual middleware function that will be called. It is of type: <code>function(bot, update, next)</code> on <code>incoming</code> and <code>function(bot, update, message, next)</code> on <code>outgoing</code>. The <code>next</code> parameter can be omitted if your controller returns a promise. Examples below ensue.</td>
</tr>
<tr>
<td>includeEcho</td>
<td>(<strong>optional</strong>) Only valid for <strong>incoming</strong> middleware. Whether or not to run this middleware on echo updates. <strong>Defaults to false</strong>.</td>
</tr>
<tr>
<td>includeDelivery</td>
<td>(<strong>optional</strong>) Only valid for <strong>incoming</strong> middleware. Whether or not to run this middleware on delivery updates. <strong>Defaults to false</strong>.</td>
</tr>
<tr>
<td>includeRead</td>
<td>(<strong>optional</strong>) Only valid for <strong>incoming</strong> middleware. Whether or not to run this middleware user &quot;user read&quot; updates. <strong>Defaults to false</strong>.</td>
</tr>
</tbody>
</table>
<h4 id="botmasterusewrapped"><code>botmaster.useWrapped</code></h4>
<p>There is another way to declare middleware in botmaster as of v3. It is by using the useWrapped method. This method should be used after all your normal middleware has been setup using <code>botmaster.use</code>. Essentially, what it does is setup an incoming middleware at the very beginning of your incoming middleware stack and another one at the very end of your outgoing middleware stack.</p>
<p>Its signature looks like this:</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>incomingMiddlewareObject</td>
<td>a valid incoming middleware object. (as described above)</td>
</tr>
<tr>
<td>outgoingMiddlewareObject</td>
<td>a valid outgoing middleware object. (as described above)</td>
</tr>
</tbody>
</table>
<p>And it would be used as such:</p>
<pre><code class="lang-js">botmaster.useWrapped(incomingMiddleware, outgoingMiddleware);
</code></pre>
<p>Where <code>incomingMiddleware</code> and <code>outgoingMiddleware</code> are valid middlewares of their respective types.
This is useful if writing a middleware package that want to be first to get the update object and last to see it when it goes out.
It is used in <a href="https://github.com/botmasterai/botmaster-session-ware" target="_blank">botmaster-session-ware</a> for example.</p>
<h4 id="where-is-my-middleware">Where is my middleware</h4>
<p>Although I doubt most would want to use this, it&apos;s good to know that middleware is accessible via all botmaster instances. Middleware stacks are exposed via <code>botmaster.middleware.incomingMiddlewareStack</code> and
<code>botmaster.middleware.outgoingMiddlewareStack</code>. Unless you really know what you are doing, it is best to leave those alone.</p>
<h2 id="external-middleware">External middleware</h2>
<p>This is all great. But Using the code in <code>addButtonsToMessage</code> to add buttons to your message is probably not the best. Indeed, external middleware packages provide better solutions to this problem. To solve this particular problem, I would suggest having a look at <a href="../middleware/fulfill.md">fulfill</a>. Like in any other framework that contains middleware, middleware can be put into packages. These packages are then available and downloadable via <code>yarn</code> or <code>npm</code> and thus easily accessible in your code. </p>
<p>Have a look at the <a href="../middlewares/">middlewares</a> to see what official middleware is out there.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="bot-object.html" class="navigation navigation-prev " aria-label="Previous page: Bot object">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="incoming-update.html" class="navigation navigation-next " aria-label="Next page: Incoming update">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Middleware","level":"1.4.2","depth":2,"next":{"title":"Incoming update","level":"1.4.3","depth":2,"path":"working-with-botmaster/incoming-update.md","ref":"working-with-botmaster/incoming-update.md","articles":[]},"previous":{"title":"Bot object","level":"1.4.1","depth":2,"path":"working-with-botmaster/bot-object.md","ref":"working-with-botmaster/bot-object.md","articles":[]},"dir":"ltr"},"config":{"plugins":["versions","expandable-chapters"],"root":"./docs","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"versions":{"type":"branches","gitbookConfigURL":"https://raw.githubusercontent.com/botmasterai/botmasterai.github.io/master/book.json","options":[{"value":"http://botmasterai.com/documentation/latest/","text":"latest"},{"value":"http://botmasterai.com/documentation/latest/","text":"Version 3.0.8","selected":true},{"value":"http://botmasterai.com/documentation/v2.3.1/","text":"Version 2.3.1"}]},"expandable-chapters":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"gitbook":"*"},"file":{"path":"working-with-botmaster/middleware.md","mtime":"2017-04-04T16:49:24.000Z","type":"markdown"},"gitbook":{"version":"3.2.2","time":"2017-04-17T21:09:48.508Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-versions/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

