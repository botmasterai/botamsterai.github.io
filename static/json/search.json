[
    {
        "uri": "/content/articles/frameworks-comparison",
        "title": "Frameworks comparison",
        "content": "\ntl;dr\n\nUse Botmaster If you want to build platform agnostic conversational bots using a system like Watson Conversation [or your own system] to manage 1 on 1 conversations (On Messenger, Slack, Twitter, Telegram, socket.io or more). e.g. a personal assistant, customer support etc.\n\nUse Botkit if you want to build platform dependant bots on either Slack or Twilio while managing simple conversations based on regex or also more complex ones using again Watson Conversation or wit etc. You can now also use Microsoft Bot Framework with Botkit. Although I'm not too sure why one would want to use  wouldn't just use MS Bot Framework without Botkit.\n\n Main article\nAlthough it might seem at first glance like the two frameworks (and other similar ones out there) were created with the same goal in mind, things are quite far from that. Let's have a look at how one of these frameworks compare, namely Botkit.\n\nBotkit was initially created to allow developers to easily build bots of all types that would be available on Slack. Although it now allows developers to build bots for twilio IP messaging and Facebook Messenger too. It was first published in December 2015\n\nBotmaster, on the other hand, is a lightweight framework created after answering the following question: How can I minimise the amount of code a developer has to write in order to create a 1-on-1 conversational chatbot that works on multiple different platforms. It was first published to Github on August 2016.\n\nDue to the differences in application intents between both frameworks, the design differs in many ways.\n\nMessage format\n---\n\nBotkit's messages are only standardized to some extent. Because Botkit it not opinionated, it doesn't make any assumption on what a message attachments or message quick_replies should look like and what they would map to on different platform.\n\nThis means that a Facebook messenger message with an image attachments will look something like this:\n\n{\n  user: idofsender,\n  channel: idofsender, // also\n  timestamp: unix miliseconds timestamp,\n  seq: messagesequenceid,\n  mid: message_id,\n  attachments: [\n    {\n      type: 'image',\n      payload: {\n        url: 'https://scontent.xx.fbcdn.net/v/.....'\n      }\n    }\n  ]\n}\n\nWhile a Twilio IPM message (Twilio IPM only supports text) will look like this:\n\n{ ChannelSid: some_id,\n  EventType: 'onMessageSent',\n  InstanceSid: some_id,\n  Attributes: '{}',\n  DateCreated: '2016-07-29T18:42:35.686Z',\n  Index: '1',\n  From: 'SneakyQuincyEssex',\n  MessageSid: some_id,\n  Identity: 'SneakyQuincyEssex',\n  Body: 'yo',\n  AccountSid: some_id,\n  text: 'yo',\n  from: 'SneakyQuincyEssex',\n  to: undefined,\n  user: 'SneakyQuincyEssex',\n  channel: some_id }\n\nBecause of the nature of Twilio and the nature of channels and how they are dealt with, this makes sense. We'll look at what other differences this brings in the next section.\n\nStandardization is at the heart of Botmaster. The framework was really created for that purpose. In order to do that, the Facebook Messenger message format was chosen and adopted. This means that when your botmaster object receives an 'update' event from anywhere (twitter, telegram as of this writing), you can be sure that it will be of the same format as a similar message that would come from Messenger.\nTypically, it would look something like this for a message with an image attachment. Independant of what platform the message comes from:\n\n{\n  raw: platformspecificraw_update,\n  sender: {\n    id: idofsender\n  },\n  recipient: {\n    id: idofthe_recipent // will typically be the bot's id\n  },\n  timestamp: unixmilisecondstimestamp,\n  message: {\n    mid: message_id,\n    seq: messagesequenceid,\n    attachments: [\n      {\n        type: 'image',\n        payload: {\n          url: 'https://scontent.xx.fbcdn.net/v/.....'\n        }\n      }\n    ]\n  }\n};\n\nThis allows developers to handle these messages in on place only rather than doing it in multiple ones.\n\nThe bot object\n---\n\nConfusion may [and most likely will] arise when trying to understand how the bot objects returned with each message differ between both frameworks.\n\nBotkit has a concept of a controller. Controllers are not platform agnostic according to their definition. So for example a Twilio IPM controller will look like this:\n\nvar controller = Botkit.twilioipmbot({\n    debug: false,\n});\nThis controller could then spawn new Twilio IMP bots. Bots all have a fixed endpoint with a port that can be defined if you need multiple bots of the same type. The bot object is returned with every event and you can then do things like send a message or reply etc with it.\n\nFor messenger, it would look something like this:\n\nconst controller = Botkit.facebookbot({\n  access_token: messengerCredentials.pageToken,\n  verify_token: messengerCredentials.verifyToken,\n});\n\nNOTE: Because of the fixed endpoint and the fact that Botkit does not (according to their code as of Aug 18th 2016) verify the integrity of the requests using the Facebook App Secret, I would advise against using it as this means that anyone can make a request to https://YOURSERVERURL:PORT_CHOSEN/facebook/receive and fake requests from Facebook.\n\nOf course, you can have multiple controllers in your app. But you will have to manage the various types of incoming messages.\n\nBotmaster does not have this concept of a controller. In fact, if you are coming from Botkit, you can think of Botmaster as a sort of supercontroller from which you can create a bot of any type as in this example:\n\n// just an example to show what types of settings are expected\nconst otherMessengerSettings = {\n  credentials: {\n    verifyToken: messengerCredentials.verifyToken,\n    pageToken: messengerCredentials.pageToken, // access_token in Botkit\n    fbAppSecret: messengerCredentials.fbAppSecret,\n  },\n  webhookEndpoint: '/webhooksomerandom_string',\n}\n\nconst botsSettings = [{ telegram: telegramSettings }, // settings found elsewhere\n                      { messenger: messengerSettings }, // settings found elsewhere\n                      { messenger: otherMessengerSettings },\n                      { twitter: twitterSettings},]; // settings found elsewhere\n\nconst botmaster = new Botmaster({settings: botsSettings});\n\nBot objects are created under the hood and events received by each of them will be relayed to the Botmaster in the standardized Messenger format mentioned in the Message format part. Events are called updates and receiving them looks like this:\n\nbotmaster.on('update', (bot, update) = {\n});\n\nWhere the bot object would have been created with any of the 4 settings mentioned. Note the fact that there are 2 messenger settings. Because Botmaster requires an endpoint to be specified in the settings, nothing more than specifying it has to be done there. We recommend people to include some sort of a key in their endpoint as added security for Messenger (on top of the integrity verification from the Facebook app secret) and as basic security for Telegram.\n\nWorking with webhooks\n---\n\nIn order to receive messages, some platforms make the use of webhooks. Which means they will send requests to some endpoints on your server. In order to do that, both frameworks make the use of express() app objects under the hood. Botkit does so for Messenger, Twilio IPM and some of the Slack solutions. Botmaster does do for Messenger and Telegram (for now).\n\nThe standard way to deal with this in Botkit is the following:\n\nconst port = 3000;\n\ncontroller.setupWebserver(port, function(err, webserver) {\n  controller.createWebhookEndpoints(webserver)\n});\n\nAs you can see, this will create an express() webserver and send it onto the createWebhookEndpoints function. The server will now listen onto the facebook/receive endpoint on port 3000 if it is a Messenger controller. It will listen onto the '/twilio/receive' for Twilio IPM and '/slack/receive' for Slack (if using one of the services that uses webhooks).\n\nOf course, you might want to use your own express() app webserver to use accross multiple controllers or to serve all sorts of other purposes. You would do this like that in Botkit:\n\nconst express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\n.\n.\n.\ncontroller.createWebhookEndpoints(app, bot, () = {\n    console.log('This bot is online!!!');\n});\n\napp.listen(3000, function() {\n  console.log('Server up');\n});\n\nIn Botmaster, instantiating a botmaster object, will by default just start an express server under the hood for you and make it listen onto port 3000. If you want it to listen onto another port, you can just do something like this when instantiating botmaster:\n\nconst port = 3001;\nconst botmaster = new Botmaster({ settings: botsSettings,\n                                 port: port });\n\nThe webhook endpoints will be set according to your settings. Go to webhooks in the main readme to read some more about webhooks in Botmaster.\n\nIn order to use your own express app, you would do as follows in Botmaster.\n\nconst express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\n\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\n.\n.\n.\nconst botmaster = new Botmaster({settings: botsSettings,\n                                 app: app});\n\napp.listen(3000, function() {\n  console.log('Server up');\n});\n\nBy default, Botkit will use different express app webservers for each controller. Botmaster, as mentioned earlier, is a sort of supercontroller. Because of that, it uses the same express webserver accross all channels by default.\n\nSupported Platforms\n---\nThe following are platforms that are supported out of the box. Both frameworks allow developers to write their own integrations and npm packages might exist for the a platform you are interested in.\n\n|   | Botmaster| Botkit |\n|---|---|---|\n|Facebook Messenger| x | x |\n|Slack| x | x |\n|Twilio IPM| | x |\n|Twitter DM| x |  |\n|Telegram| x |  |\n|WebSockets| x | |\n|MS Bot framework|| x |\n\nConversations\n---\n\nBotkit allows developers to specify a deterministic conversation flow within the code to simplify such flows. This is definitely handy and something that can help when creating Slack and Twilio bots\n\nBecause Botmaster was initialy built mainly as a standardization agnostic layer that assumes your messages will be sent to some sort of AI service like Watson Conversation and others, this hasn't been builtin to the first version. This is however something that will come soon (in a different form from the ones in Botkit). Depending on requests however, it could come sooner or later.\n\nConclusion\n---\nI hope this all made some sort of sense to you and that you are now able to make a sensible decision with respect to which framework to use.\n\nI realize there are other frameworks out there too that I haven't mentioned. If anyone would like to look into them and tell me what the differences are, I'd be happy to add them to another file.\n",
        "tags": []
    },
    {
        "uri": "/content/articles/index",
        "title": "Other Articles",
        "content": "\nOTHER ARTICLES\n\n Botmaster or botkit\n",
        "tags": []
    },
    {
        "uri": "/content/documentation/botmaster",
        "title": "Botmaster",
        "content": "\nWhat is Botmaster?\n\nBotmaster is a lightweight highly extendable, highly configurable chatbot framework. It was meant to be used both in small scale and large scale projects. Its purpose is to integrate your chatbot into a variety of messaging channels - currently Facebook Messenger, Slack, Twitter DM, Telegram and socket.io. Using botmaster looks something like this:\n\nconst Botmaster = require('botmaster');\nconst config = require('./config');\n\nconst botTypes = Botmaster.botTypes;\nconst botmaster = new Botmaster();\n\nbotmaster.addBot(new botTypes.MessengerBot(config.messengerSettings));\nbotmaster.addBot(new botTypes.SlackBot(config.slackSettings));\nbotmaster.addBot(new botTypes.SocketioBot(config.socketioSettings));\nbotmaster.addBot(new botTypes.TwitterBot(config.twitterSettings));\nbotmaster.addBot(new botTypes.TelegramBot(config.telegramSettings));\n\nbotmaster.on('update', (bot, update) = {\n  bot.reply(update, 'Right back at you!');\n});\n\n Botmaster is platform agnostic\n\nBotmaster is platform agnostic in two important ways. Firstly, out of the box, developers can have bots running on Facebook Messenger, Slack, Twitter DM, Telegram and their personal webapp/app via socket.io with not only a standardized text message format, but also a standardized attachment format. Secondly, BotMaster makes no assumptions about the back-end bot itself - you can write code that allows BotMaster to call conversational engines such as IBM Watson's conversation API, open source frameworks or even write the conversation engine yourself.\n\nBotmaster's Philosophy\n\nIts philosophy is to minimise the amount of code developers have to write in order to create 1-on-1 conversational chatbots that work on multiple platforms. It does so by defining a standard with respect to what format messages take and how 1-on-1 conversations occur. Messages to/from the various messaging channels supported are all mapped onto this botmaster standard, meaning the code you write is much reduced when compared to a set of point:point integrations.\n",
        "tags": []
    },
    {
        "uri": "/content/getting-started/index",
        "title": "Getting started",
        "content": "\nGETTING STARTED\n\n Installation\nQuickstart\n Getting set up\nFacebook Messenger Setup\n Slack Setup\nSocket.io Setup\n Twitter Setup\nTelegram setup\n Webhooks\n",
        "tags": []
    },
    {
        "uri": "/content/getting-started/installation",
        "title": "Installation",
        "content": "\nMake sure you have Node.js and npm installed on your machine. If you don't, I recommend using nvm to manage your node versions. Find out more about it here\n\nOnce you have node, create a new project directory and go into it:\n\nmkdir mybotmasterproject && cd mybotmasterproject\n\nMake sure you initialize a node project in the new directory and going through the prompt by doing:\n\nnpm init\n\nFinally, install the botmaster npm package.\n\nnpm install --save botmaster\n\nThat should do!\n",
        "tags": []
    },
    {
        "uri": "/content/getting-started/messenger-setup",
        "title": "Facebook Messenger Setup",
        "content": "\nGetting your Credentials\n\nIf you don't already have these, follow the steps 1-4 on the Facebook Messenger guide:\nhttps://developers.facebook.com/docs/messenger-platform/guides/quick-start\n\nIn step 2, where you setup your webhook, no need to code anything. Just specify the webhook, enter any secure string you want as a verify token(verifyToken) and copy that value in the settings object. Also, click on whichever message [those are \"update\"s using botmaster semantics] type you want to receive from Messenger (messagedeliveries, messages, messagepostbacks etc...).\n\nTo find your Facebook App Secret (fbAppSecret), navigate to your apps dashboard and under App Secret click show, enter your password if prompted and then there it is.\n\n Code\n\nconst Botmaster = require('botmaster');\nconst botmaster = new Botmaster();\n\nconst messengerSettings = {\n  credentials: {\n    verifyToken: 'YOUR verifyToken',\n    pageToken: 'YOUR pageToken',\n    fbAppSecret: 'YOUR fbAppSecret',\n  },\n  webhookEndpoint: '/webhook1234',\n};\n\nconst messengerBot = new Botmaster.botTypes.MessengerBot(messengerSettings);\nbotmaster.addBot(messengerBot);\n\nbotmaster.on('update', (bot, update) = {\n  bot.reply(update, 'Hello world!');\n});\n\nWebhooks\n\n{{% notice note %}}\nIf you are not too sure how webhooks work and/or how to get them to run locally, go to webhooks to read some more.\n{{% /notice %}}\n",
        "tags": []
    },
    {
        "uri": "/content/getting-started/quickstart",
        "title": "Quickstart/mini-tutorial",
        "content": "\nIn this quickstart tutorial, you'll learn how to quickly get a simple Botmaster project up and running.\nThe bot will work on both the Facebook Messenger and Twitter (DMs) platforms. Support for other platforms can be added\nvery easily as will be described later.\n\nBecause we only want to get acquainted with Botmaster, we'll build a very naive and simple bot that doesn't really do much. i.e. with no support for natural language processing, conversational flows etc... We just want to expose how botmaster works here.\n\nIt'll look something like this on Facebook Messenger:\n\nAnd like this on Twitter (DMs):\n\nThis mini-tutorial assumes that you have already installed botmaster as documented in the installation guide: here.\n\nStep 1: Setup\n\nIn the folder in which you installed botmaster, create an app.js file and put the following lines in it:\n\nconst Botmaster = require('botmaster');\n\nconst botmaster = new Botmaster();\n\nNothing special is going on here. We're just requiring the Botmaster class (exposed via the botmaster package) and creating a new instance of Botmaster.\n\nNow, in order for Botmaster to manage out bots, we obviously need to create at least one bot. We'll go on and create couple. One Facebook Messenger bot and one Twitter DM bot.\n\n{{% notice info %}}\nTo complete the following steps, you will need to gather valid credentials for the platforms you want to use. Read the following small guides for Facebook Messenger and Twitter DMs if you don't have credentials for these platforms yet:\nmessenger, twitter. Other guides are also available in this getting-started section.\n{{% /notice %}}\n\nconst MessengerBot = Botmaster.botTypes.MessengerBot;\nconst TwitterBot = Botmaster.botTypes.TwitterBot;\n\nconst messengerSettings = {\n  credentials: {\n    verifyToken: 'YOUR verifyToken',\n    pageToken: 'YOUR pageToken',\n    fbAppSecret: 'YOUR fbAppSecret',\n  },\n  webhookEndpoint: '/webhook1234', // botmaster will mount this webhook on https://YourDomainName/messenger/webhook1234\n};\n\nconst twitterSettings = {\n  credentials: {\n    consumerKey: 'YOUR consumerKey',\n    consumerSecret: 'YOUR consumerSecret',\n    accessToken: 'YOUR accessToken',\n    accessTokenSecret: 'YOUR accessTokenSecret',\n  }\n}\n\nconst messengerBot = new MessengerBot(messengerSettings);\nconst twitterBot = new TwitterBot(twitterSettings);\n\nThere seems to be quite a bit going on here. Let's look at it all line by line:\n\nOn the first two lines we get the MessengerBot and TwitterBot classes exposed via Botmaster. The Botmaster package comes bundled in with 5 bot classes so that you can get started straight away. They are all exposed via: Botmaster.botTypes, where Botmaster is gotten via const Botmaster = require('botmaster');\n\nNext, settings objets for both platforms are created: namely the messengerSettings and twitterSettings objects. To see how to gather the necessary credentials, have a look at these small guides: messenger, twitter.\n\nIn the messengerSettings object, the webhookEndpoint parameter simply indicates to Botmaster what endpoint we want the Facebook Messenger messages to come into. I.e. if you host your Botmaster app on, say, \"https://somebotmasterapp.com\", Messages coming in from Facebook Messenger will hit: \"https://somebotmasterapp.com/messenger/webhook1234\". This works because Botmaster is built on top of express.js. Read more about webhooks and how to make them work locally here.\n\nAs it stands, these bot objects don't really have much to do with our previously create botmaster one. We want to be able to manage them from the botmaster obejct. So we will now add (or mount) these newly created bot objects onto the botmaster object we created previously. So right after these few lines, enter the following:\n\nbotmaster.addBot(messengerBot);\nbotmaster.addBot(twitterBot);\n\nThese lines simply indicate to botmaster that it should be notified of all activity going on within our two bot objects. But still, botmaster doesn't actually do anything yet. let's change this!\n\n Step 2: listening to events\n\nIn order for botmaster to be notified of any activity going on (i.e. users sending messages to your bots), we'll need to listen to the 'update' event that fires whenever a user sends a message to one of our bots. It looks like this:\n\nbotmaster.on('update', (bot, update) = {\n  console.log(update, null, 2);\n});\n\n{{% notice warning %}}\nYou should ever only have one .on('update',...) listener by botmaster app, as events are asynchronous in nature and having multiple ones will result in unforeseen occurrences.\n{{% /notice %}}\n\nAt this point, whenever a message (or update in Botmaster semantic) is received by any of your bots, you will be printing to the console the received message. You'll also note that the callback function has a bot object associated with it. This object will be either of messengerBot or twitterBot in this example depending on what bot actually received the update\n\nThis is great. But what if I want to send something back to the user. Well, let's have a look.\n\nStep 3: sending replies\n\nThe easiest thing to do to have a bot that answers you is the following; replace the Step 2 code with this:\n\nbotmaster.on('update', (bot, update) = {\n  bot.reply(update, 'Hello World!');\n});\n\nThis really doesn't do much however. Let's try to get to something like what we saw in the pictures at the beginning of this tutorial. Let's replace this code with this:\n\nbotmaster.on('update', (bot, update) = {\n  if (update.message.text === 'hi' ||\n      update.message.text === 'Hi' ||\n      update.message.text === 'hello' ||\n      update.message.text === 'Hello') {\n    bot.reply(update, 'well hi right back at you');\n  } else if (update.message.text.indexOf('weather')  -1) {\n    bot.sendTextMessageTo('It is currently sunny in Philadelphia', update.sender.id);\n  } else {\n    const messages = ['I\\'m sorry about this.',\n                      'But it seems like I couldn\\'t understand your message.',\n                      'Could you try reformulating it?']\n    bot.sendTextCascadeTo(messages, update.sender.id)\n  }\n});\n\nWhat's going on here is really fairly straightforward. The point of this code is really to expose to you the different ways there are to send messages in botmaster. In the first conditional block, I look to see if the text from the platform says something like \"hello\", if so, answer that way using the reply helper function. However, if the message contains the word \"weather\", we reply using the sendTextMessageTo helper function. In any other situation, we reply in a cascade of text messages using the sendTextCascadeTo helper function to send multiple text messages one after the other. If you want to see all the available send helper functions available to you in Botmaster, check it out here.\n\n Closing Comments\n\nNow as mentioned at the beginning of this tutorial, this bot is not a very good or helpful bot. It's quite dumb and doesn't even leverage a lot of the Botmaster goodies like middlewares, using socket.io to have a bot on your own website. Or adding support for a different bot class as mentioned here. More importantly, it doesn't really understand anything being told to it and have a look at the list of tutorials we have to see how to leverage NLU tools such as Watson Conversation, Wit.ai, Api.ai and rasa-nlu with Botmaster.\n",
        "tags": []
    },
    {
        "uri": "/content/getting-started/slack-setup",
        "title": "Slack Setup",
        "content": "\nThe Botmaster Slack bot\n\nBecause Slack works slightly differently from the other platforms covered in the core Botmaster package, I will briefly explain here what your botmaster Slack bot will be exactly.\n\nAs you surely know, Slack is a product that enables team members to communicate easily with one another. because of that, one team member can't just \"add\" a bot for herself in the same way one would in Facebook Messenger or Telegram or other.\n\nTeams can either build a bot that will only live within their own slack team. Or they can package a bot in a Slack app that \"packages\" the bot.\nAdmin team members can add support for a bot (by installing an App that packages said bot) and then team members can start communicating with it as they would with another team member. At this point, they would be communicating with what is known as, in Slack semantics, a bot user.\n\nAll the information required by Slack concerning this is setup in the slackSettings object within Botmaster. This will allow us to create a Slack Bot object that communicates to end users via this bot user that needs to be set up on Slack's end. Because this whole setup and gathering the proper credentials is not as trivial as one might want and quite unclear on their website, here's a mini-tutorial to get you started with Botmaster * Slack.\n\n Botmaster Slack bot mini-tutorial\n\nFollowing these steps, you will have a fully functional Slack bot using Botmaster that can then be edited as wanted. This mini-tutorial uses localtunnel to expose one of your ports to the world. see why you might want to use this and how to install and setup localtunnel here for your local botmaster project. You can use ngrok or any other service you know or find suitable and achieve the same result.\n\nCreate an app\n\nNavigate to: https://api.slack.com/apps and make sure you are signed in. If you aren't you will be redirected to your team's slack once logged in and will need to go back to the mentioned link.\n\nClick the create new App button and enter any App Name you want. This won't be the name of the bot user. However, the name should ideally be related to your bot user so as not to confuse your users. For instance, if your bot user will be called my_super_bot, calling the app something like My Super Bot App would make sense.\n\n Get your first credentials\n\nOn this page you were redirected to, you will find an App credentials section. Both your Client ID (clientId in Botmaster) and your Client Secret (clientSecret in Botmaster) are here. Take note of them.\n\nSetup Your App's OAuth Webhook\n\nYou don't need to know anything about OAuth to complete this step. Just know that this URL will be called when people are installing/authorizing your app.\n\nIn the left panel, click on the OAuth & Permissions tab and enter your webhook in the Redirect URL(s) field as shown here:\n    \nThis URL has to be of the form: https://\\your_base_url\\/slack/\\webhookEndpoint\\. For example, if I am using localtunnel to test the bot locally, and started localtunnel by running the following:\n   lt -p 3000 -s botmastersubdomain\n I would set my Redirect URL(s) to: https://botmastersubdomain.localtunnel.me/slack/webhookd24sr34se (based on the webhookEnpoint set in my slackSettings in the \"Start your Botmaster App Locally\" section). Click on Save Changes.\n\n Add a Bot User\n\nGo to Bot Users and click on the Add a Bot User button. Select a name for your bot (e.g. mysuperbot) and click the Add Bot User button.\n\nGet the rest of your credentials\n\nNavigate to the Event Subscriptions tab and click on the toggle button in the to right corner to on. Then in the Request URL field that pops up, enter the same URL as in the OAuth & Permissions tab. You will get an error. This is normal and is due to two reasons. Firstly, we don't actually have an app started and listening at the mentioned URL and secondly because even if we did, we don't have our App's verification Token. Let's fix this!\n\nNavigate back to Basic Information and note that you now have a Verification Token in the App Credentials box. Take note of it.\n\n Start your Botmaster App Locally\n\nStart your botmaster app in any project folder you might want (see here if you haven't installed botmaster yet). To start the botmaster project, you'll want to create an app.js file with the following contents:\n\nconst Botmaster = require('botmaster');\nconst botmaster = new Botmaster();\n\nconst slackSettings = {\n  credentials: {\n    clientId: 'YOUR app client ID',\n    clientSecret: 'YOUR app client secret',\n    verificationToken: 'YOUR app verification Token'\n  },\n  webhookEndpoint: '/webhookd24sr34se',\n  storeTeamInfoInFile: true,\n};\n\nconst slackBot = new Botmaster.botTypes.SlackBot(slackSettings);\nbotmaster.addBot(slackBot);\n\nbotmaster.on('update', (bot, update) = {\n  bot.reply(update, 'Hello world!');\n});\nand place it at the root of your project folder. Replace the credentials with the ones you have gathered. Run node app.js to start the app. Let's now expose our bot to the world.\n\nFor the webhook to work locally, you'll now need to make sure you've started localtunnel. If you are doing all of that from a server that already has a Domain Name, you won't need to do this. But I am assuming most people are doing this from their local computer. so in the command line, run something like this:\nlt -p 3000 -s wantedbaseurlforyour_bot\n\nSetup Your App's Events and Events Webhook\n\nGo back to the Event subscription page and enter your webhook url again. This should now work and look something like this:  Scroll down and click on Add Bot User Events. At the minimum, add the following events:\n    message.ipm\n    message.channels\n    message.im\n    message.groups\nClick Save Changes\n\n Install your Slack App\n\nWe're almost done here. We need a way to install our app to test it out. This is done via what is called a Slack button. because botmaster manages all the nitty-gritty parts of this process, all you need to do is create a views folder in your project folder and create an index.html file in this views folder with the following contents\na href=\"https://slack.com/oauth/authorize?scope=bot&clientid=YOURAPPCLIENTID\"\n  <img alt=\"Add to Slack\" height=\"40\" width=\"139\"\n  src=\"https://platform.slack-edge.com/img/addtoslack.png\"\n  srcset=\"https://platform.slack-edge.com/img/addtoslack.png 1x,\n          https://platform.slack-edge.com/img/addtoslack@2x.png 2x\" /\n/a\nNote that you'll need to replace YOUR_APP_CLIENT_ID in the href with your own. You definitely don't want to put in your client secret here!\n\nTry out your bot!\n\nAssuming your botmaster app and localtunnel are still running, open your index.html file (not in a text editor, but actually in a browser) by double clicking on it. Authorize your newly created app to add it to your team. You should now be redirected to your teams slack and be able to chat to your bot.\n\n Make your Bot Available to the World\n\nYou might actually want to allow others to install your app by using the Slack Button. However, to do so you will need to host it somewhere. We'll take advantage of the fact that botmaster uses express.js under the hood and edit our app.js file to look like this:\n\nconst Botmaster = require('botmaster');\nconst express = require('express'); // added\n.\n.\n.\nbotmaster.app.use(express.static(__dirname + '/views')); //added\n// or if you don't want it at the root of your app, add this:\nbotmaster.app.use('/slack', express.static(__dirname + '/views')); // added\n\nbotmaster.on('update', (bot, update) = {\n  bot.reply(update, 'Right back at you');\n});\nMake sure to add either one of the botmaster.app.use... lines.\nIf you pick the first one, navigate to your URL (https://botmastersubdomain.localtunnel.me/ for this example) and you will see the button.\nIf your pick the second one, navigate to your sub URL (https://botmastersubdomain.localtunnel.me/slack for this example) to see the Slack button.\n\nWebhooks\n\nNow as with any other platform using Webhooks, you'll need to update these to your production Domain Name once you deploy your code to production. And in a more general sense, if you are still unsure how webhooks work within the botmaster framework, go here\n",
        "tags": []
    },
    {
        "uri": "/content/getting-started/socketio-setup",
        "title": "Socket.io Setup",
        "content": "\nCode\n\n Server\nconst Botmaster = require('botmaster');\nconst botmaster = new Botmaster();\n\nconst socketioSettings = {\n  id: 'SOMEBOTIDOFYOUR_CHOOSING',\n  server: botmaster.server, // this is required for socket.io. You can set it to another node server object if you wish to. But in this example, we will use the one created by botmaster under the hood\n};\n\nconst socketioBot = new Botmaster.botTypes.SocketioBot(socketioSettings);\nbotmaster.addBot(socketioBot);\n\nbotmaster.on('update', (bot, update) = {\n  bot.reply(update, 'Right back at you');\n});\n\nClient\nconst io = require('socket.io-client');\n\nconst socket = io('ws://localhost:3000');\n\nsocket.on('connect', function() {\n  const message = {\n    text: 'Hey there botmaster!'\n  };\n\n  socket.send(message);\n});\n\n The Botmaster Socket.io bot\n\nSocket.io is a great library that allows developers to write apps using webSockets (with fallbacks to http long-polling and others when webSockets aren't available on the client). You can read more about it on their own website here: http://socket.io.\n\nBecause you might want to have a bot that not only works on some arbitrary platform but also on your own webapp/app, support for socket.io was added to the Botmaster core. Although Socket.io enables developers to use their technology in a bunch of different applications, the fact that you want to use it in Botmaster means that you want to handle 1-1 conversations between users and your bot (managed by botmaster).\n\nIf you've never used both botmaster and socket.io, It's probably still pretty unclear how all of this fits in together. Hopefully the next section will help you understand and get started with this.\n\nBotmaster Socket.io bot mini-tutorial\n\nBy following these steps, you will have a fully functional Socket.io bot using botmaster. The client will live in a tiny web-page. The point of this tutorial is to get you started so that you can develop it further in any way you wish. This is completely based on the socket.io web \"get started\" guide found here: http://socket.io/get-started/chat/.\n\n Server\n\nAfter making sure that we have a project folder with a node.js project initialised and the botmaster package in it as per the installation guide.\nWe want to make sure botmaster is setup and make sure that messages coming from a websocket connection are received. So in our poject folder, in our app.js file, we simply copy the code found at the top of this page:\n\nconst Botmaster = require('botmaster');\n\nconst botmaster = new Botmaster();\n\nconst socketioSettings = {\n  id: 'SOMEBOTIDOFYOUR_CHOOSING',\n  server: botmaster.server,\n};\n\nconst socketioBot = new Botmaster.botTypes.SocketioBot(socketioSettings);\nbotmaster.addBot(socketioBot);\n\nbotmaster.on('update', (bot, update) = {\n  bot.reply(update, 'Right back at you');\n});\n\nWe will need to add a couple of lines to this code because we will be serving a webpage from our server. Not just listening on for botmaster messages. To do so, we take advantage of the fact that botmaster is built on top of express and that this app es exposed via botmaster.app. We also assume that we will be serving our static assets (the components of our webpage) from a folder called 'public' within our project directory. Our updated code looks like this:\n\nconst express = require('express'); //added\nconst Botmaster = require('botmaster');\n\nconst botmaster = new Botmaster();\nbotmaster.app.use(express.static(${__dirname}/public)); //added\n\nconst socketioSettings = {\n  id: 'SOMEBOTIDOFYOUR_CHOOSING',\n  server: botmaster.server,\n};\n\nconst socketioBot = new Botmaster.botTypes.SocketioBot(socketioSettings);\nbotmaster.addBot(socketioBot);\n\nbotmaster.on('update', (bot, update) = {\n  bot.reply(update, 'Right back at you');\n});\n\nbotmaster.on('error', (bot, err) = {\n  console.log(err.stack);\n});\n\nWe also added the botmaster 'error' event listener, because that's just always good to do.\n\nClient side\n\nAs mentioned in the Server side, we will create a folder named 'public' within our poject dir. In it, we will have the following three files:\n\nindex.html\nstyle.css\nclient_app.js\n\nSo that your final tree structure looks like this:\n\nyourprojectfolder\n├── app.js\n└── public\n    ├── client_app.js\n    ├── index.html\n    └── style.css\n\nIn the index.html file, we will put some very basic html that looks like this:\n\n!doctype html\nhtml\n  head\n    titleBotmaster bot/title\n    link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"\n  /head\n  body\n    div class=\"chat\"\n      ul id=\"messages\"/ul\n      form id=\"form\" action=\"\"\n        input type=\"text\" id=\"text-input\" autocomplete=\"off\" /buttonSend/button\n      /form\n    /div\n\n    script src=\"/socket.io/socket.io.js\"/script\n    script src=\"client_app.js\"/script\n  /body\n/html\n\nThe important line here is the line where we are importing socket.io. This works because socket.io adds a path to our server (in this case, a server created by botmaster under the hood) to serve this exact endpoint.\nThe other imports are simply the ones we will be creating.\n\nIn the style.css file, simply add the following:\n\n{\n  margin: 0;\n  padding: 0;\n  box-sizing:\n  border-box;\n}\n\nbody {\n  font: 13px Helvetica, Arial;\n}\n\nform {\n  background: 000;\n  padding: 3px;\n  position: fixed;\n  bottom: 0;\n  width: 100%;\n}\n\nform input {\n  border: 0;\n  padding: 10px;\n  width: 90%;\n  margin-right: .5%;\n}\n\nform button {\n  width: 9%; background: rgb(130, 224, 255);\n  border: none; padding: 10px;\n}\n\nmessages {\n  list-style-type: none;\n  margin: 0;\n  padding: 0;\n}\n\nmessages li {\n  padding: 5px 10px;\n}\n\nmessages .botmaster-message {\n  background: eee;\n}\nThis is the exact look from the socket.io tutorial mentioned above (and mostly their code too).\n\nFinally, in the client_app.js file, you should include the following:\n\n// the following line could also be: \"var socket = io('ws://URL:PORT_Number?botmasterUserId=wantedUserId');\"\n// if you know you will be communicating with a server different from the one that served you the page you are on.\n// this only works because the socket.io library assumes with this syntax that the socket.io server\n// lives at the same address as the server that served this page (this should mostly be your case)\nvar socket = io('?botmasterUserId=wantedUserId');\n\n// just get the html elements we will be needing by ID\nvar form = document.getElementById('form');\nvar textInput = document.getElementById('text-input');\nvar messages = document.getElementById('messages');\n\nform.onsubmit = function(event) {\n  // just making sure the page isn't refreshed\n  event.preventDefault();\n  // don't do anything if there is no text\n  if (!textInput.value) {\n    return;\n  }\n  // Add the user message to the web page\n  messages.insertAdjacentHTML('beforeend',\n    li class=\"user-message\"${textInput.value}/li);\n  // create a botmaster compatible message from the text input by the user\n  const message = {\n    text: textInput.value,\n  };\n  // send the message over the webSocket\n  socket.send(message);\n  // finally, clear the user textInput field\n  textInput.value = '';\n};\n\nsocket.on('message', function(botmasterMessage){\n  var textMessage = botmasterMessage.message.text;\n\n  messages.insertAdjacentHTML('beforeend',\n    li class=\"botmaster-message\"${textMessage}/li);\n});\n\nYou should have a read through this code to make sure you understand it as that is the code communicating with our botmaster backend.\n\nOn the first line, we call: var socket = io('?botmasterUserId=wantedUserId');. This effectively opens up a socket connection with our backend by making a request to something like this: io('ws://localhost:3000?botmasterUserId=wantedUserId');. Here as you can see, we are setting a query param called botmasterUserId to \"wantedUserId\". This is done because we want to make sure that when we are getting updates in our backend, the update.sender.id part will be what we set it to here and not anything else (by default the randomly allocated socket.id value). This is even more important when your users can connect from different clients and you want to make sure the botmaster reply is propagated to all the clients.\n\nIn the form.onsubmit part, we make sure that the text contained in the input cell is correctly formatted then sent to botmaster via the websocket. We also make sure to display it in our page and to then clear the input.\n\nIn the socket.on('message') part, we simply display the received message.\n\nNow that our code is here, simply go to your command line and run node app.js. If you now open a browser to 127.0.0.1:3000 you should be able to chat with your pretty useless (for now) bot. Just like this:\n\nSecurity\n\nYou might be wondering how you can secure your Botmaster socket.io app. I.e. how can you make sure that a client connecting with a certain id really is who they claim they are. Well, this part is actually left to you, the developer to do. I didn't want to make any assumptions with regards to what people would want to use to secure their app. So what I do is expose the socket.io server object through the bot object. It can be accessed in the following way\n\nsocketioBot.ioServer\n\nThen you'll be able to register a middleware function to your socker.io server as such:\n\nsocketioBot.ioServer.use((socket, next) = {\n  if (socket.request.headers.cookie) return next();\n  next(new Error('Authentication error'));\n});\n\nThis is shamelessly stolen from the socket.io documentation here: http://socket.io/docs/server-api/namespace#use(fn:function):namespace\n\nThis function will be executed every time there is an incoming socket connection. Indeed, no need to do so on every message as once the connection is made, all transfers are secured on the open socket. That's really the whole point of webSockets.\n",
        "tags": []
    },
    {
        "uri": "/content/getting-started/telegram-setup",
        "title": "Telegram Setup",
        "content": "\nCredentials\n\nAll you need here is an authToken. In order to get one, you will need to either create a new bot on telegram.\n\nBasically, you'll need to send a /newbot command(message) to Botfather (go talk to him here). Once you're done with giving it a name and a username, BotFather will come back to you with your authToken. Make sure to store it somewhere. More info on BotFather can be found here if needed.\n\nFor more on Telegram, you can find the telegram api docs here\n\n Webhooks\n\nSetting up your webhook requires you to make the following request outside of Botmaster (using curl for instance or a browser):\n\nhttps://api.telegram.org/botauthToken/setWebhook?url='Your Base URL'/telegram/webhook1234\n\n{{% notice warning %}}\nBecause Telegram doesn't send any type of information to verify the identity of the origin of the update, it is highly recommended that you include a sort of hash in your webhookEndpoint. I.e., rather than having this: webhookEndpoint: '/webhook/', do something more like this: webhookEndpoint: '/webhook92ywrnc9qm4qoiuthecvasdf42FG/'. This will assure that you know where the request is coming from.\n{{% /notice %}}\n\n{{% notice note %}}\nIf you are not too sure how webhooks work and/or how to get them to run locally, go to webhooks to read some more.\n{{% /notice %}}\n\nCode\n\nconst Botmaster = require('botmaster');\nconst botmaster = new Botmaster();\n\nconst telegramSettings = {\n  credentials: {\n    authToken: 'YOUR authToken',\n  },\n  webhookEndpoint: '/webhook1234/',\n};\n\nconst telegramBot = new Botmaster.botTypes.TelegramBot(telegramSettings);\nbotmaster.addBot(telegramBot);\n\nbotmaster.on('update', (bot, update) = {\n  bot.reply(update, 'Right back at you');\n});\n",
        "tags": []
    },
    {
        "uri": "/content/getting-started/twitter-setup",
        "title": "Twitter Setup",
        "content": "\nGetting your Credentials\n\nTwitter's setup is slightly more tricky than one would wish. Because Twitter requires you to create an actual account and not a page or a bot, you'll have to do a few more steps.\n\n Setting up the bot account\n\nJust create a standard twitter account as you would any other. Name it as you want.\nnavigate to your security and privacy settings (click on your image profile  settings  privacy and security settings)\nscroll to the bottom of the page and make sure \"Receive Direct Messages from anyone\" is ticked. (currently this has to be done because of Twitter's rules concerning DMs, where in order to send a DM to someone, they have to be following you).\n\nSetting up the app\n\nNavigate to the somewhat hard to find Twitter developer app dashboard at: https://apps.twitter.com/\nClick Create New App. Enter your details (callback URL is not required if you are starting from scratch here). 'Website' can take in a placeholder like (http://www.example.com)\nNow navigate straight to the 'Permissions' tab(do this before going to the 'Keys and Access Tokens' tab). Select 'Read, Write and Access direct messages' and then click 'Update Setting'\nNavigate to the 'Keys and Access Tokens' tab. You'll find your consumerKey and consumerSecret right here\nScroll down and click on 'Create my access token'. You now have your accessToken  and your accessTokenSecret\n\n! Makes sure not to create your access token before having reset your permissions. If you do that, you will need to change your permissions then regenerate your access token.\n\nThat should about do it. Because twitter DM is not completely separate from the rest of Twitter, it behaves quite differently from the other platforms on many aspects. These points are covered in working with botmaster.\n\n Code\n\nconst Botmaster = require('botmaster');\nconst botmaster = new Botmaster();\n\nconst twitterSettings = {\n  credentials: {\n    consumerKey: 'YOUR consumerKey',\n    consumerSecret: 'YOUR consumerSecret',\n    accessToken: 'YOUR accessToken',\n    accessTokenSecret: 'YOUR accessTokenSecret',\n  }\n}\n\nconst twitterBot = new Botmaster.botTypes.TwitterBot(twitterSettings);\nbotmaster.addBot(twitterBot);\n\nbotmaster.on('update', (bot, update) = {\n  bot.reply(update, 'Right back at you');\n});\n",
        "tags": []
    },
    {
        "uri": "/content/getting-started/webhooks",
        "title": "Webhooks",
        "content": "Most platforms rely on webhooks to work. As such, you are expected to setup webhooks on the various platforms that use them in order to use Botmaster with these platforms. In the 'Getting started' part of this documentation, we briefly touched onto that for Telegram and Messenger and more deeply for Slack.\n\nIf you are still unsure what webhooks are and how they work, within the context of chatbots, they are simply a URL provided by you pointing to where you expect messages and other updates to come in.\n\nAny platform that requires webhooks won't work without a webhookEndpoint parameter in their settings. E.g. for Telegram:\n\nconst telegramSettings = {\n  credentials: {\n    authToken: 'YOUR authToken',\n  },\n  webhookEndpoint: '/webhook1234/',\n};\n\nThis will mount your telegram webhook on: https://YourDomainName:3000/messenger/webhook1234. And yes, you will need ssl in order to work with most platforms.\n\nAs an added layer of security, it is highly recommended that you include a sort of a code in your webhookEndpoint. I.e., rather that having this: webhookEndpoint: '/webhook/', do something more like this: webhookEndpoint: '/webhook92ywrnc9qm4qoiuthecvasdf42FG/'. This will assure that you know where the request is coming from. It is more important on Telegram than on other platforms as Telegram doesn't give us any way to verify the source of the message.\n\nNow we realize you will want to develop and test your code without always deploying to a server with a valid url that supports ssl.\n\nOn a local machine:\n\nWe recommend using the great localtunnel tool that proxies one of your ports to their url (with a potential wanted subdomain) using ssh.\n\nSimply install localtunnel on local machine:\n\nnpm install -g localtunnel\n\nThen run the localtunnel with a predetermined subdomain. e.g:\n\nlt -p 3000 -s botmastersubdomain //for example\n\n-p is the port and -s is the subdomain we want.\n-l is for the localhost we want to point to. This is useful is you are using botmaster inside of a container. For instance if using docker-machine, simply -l to your docker-machines ip and -p to the port that your container exposes.\n\nIn the example above, url will be: http://botmastersubdomain.localtunnel.me. Localtunnel is great and supports both ssl and non ssl request, which means we will actually wan to use: https://botmastersubdomain.localtunnel.me\n\nSo if you specified your messenger's bot webhook endpoint to, say, /webhook1234/, you will have to set up the webhook for your demo app at:\n\nhttps://botmastersubdomain.localtunnel.me/messenger/webhook1234/\n\nFor Telegram, it would look something like this:\n\nhttps://botmastersubdomain.localtunnel.me/telegram/webhook1234/\n\nIf you keep on getting an error that looks like this:\n\nyour url is: https://customname.localtunnel.me\n/usr/local/lib/node_modules/localtunnel/bin/client:58\n        throw err;\n        ^\n\nError: connection refused: localtunnel.me:44404 (check your firewall settings)\n    at Socket.anonymous (/usr/local/lib/node_modules/localtunnel/lib/TunnelCluster.js:47:32)\n    at emitOne (events.js:96:13)\n    at Socket.emit (events.js:188:7)\n    at emitErrorNT (net.js:1272:8)\n    at combinedTickCallback (internal/process/nexttick.js:74:11)\n    at process.tickCallback (internal/process/nexttick.js:98:9)\n\nThis is due to a bug in localtunnel. You can either go try out ngrok (which you will have to pay for), or try this workaround in the terminal:\n\n(while true; do\n  lt -p 3000 -s botmastersubdomain\ndone)\n\nor:\n\n( while true; do lt -p 3000 -s botmastersubdomain; done; )\n\nIf you prefer a one liner.\n\nThis will just restart the process whenever it crashes (which can happen very often...), making sure your webhook will always be up and listening for incoming requests.\n\nWhat I do in my projects is the following:\n\nInstall localtunnel in the project and save to dev-dependencies\nnpm install --save-dev localtunnel\n\nThen in my package.json, add something like this in my 'scripts':\n\n\"scripts\": {\n  .\n  .\n  \"tunnel\": \"( while true; do lt -p 3000 -s botmastersubdomain; done; )\",\n  .\n  .\n},\n\nI can then simply run the runnel as follows (most likely in another console tab):\n\nnpm run tunnel\n",
        "tags": []
    },
    {
        "uri": "/content/middlewares/fulfill",
        "title": "Fulfill",
        "content": "\nbotmaster-fulfill provides a text-friendly way to integrate actions with your bot. You supply an object of action-functions that can return synchronously or asynchronously and replace text in the response, generate new responses, or do what the response claims to do, by for example actually placing the users burger order for him using a REST API.\n\n!-- TOC depthFrom:1 depthTo:2 withLinks:1 updateOnSave:1 orderedList:0 --\n\nMarkup for your chatbot.\nQuick start\nIntroduction\nHow to use the Fulfill API\n\tFormat for the action spec\n\tMore info on params:\n\tAdditional controller configuration options\nUsing botmaster-fulfill\n\tAdditional middleware options\nUsing standalone without botmaster\nSetup hint - drag and drop action modules\nDebug\n\n!-- /TOC --\n\nMarkup for your chatbot.\n\n Chabot: \"Let me see if I can place your order, pause / placeOrder id=12 /\"\n \nYou just built a chatbot. Its funny, and it says useful stuff. But how do you get it to do something?\n\nShaquille O'Neal: Little man, I ordered tomatoes on this Good Burger, and I don't see no tomatoes!\n\nEd: Well, hang on... modifyOrder style='slap'Tomatoes/modifyOrder\nGood Burger, Brian Robbins (1997)\n\nFulfill makes this easy with declarative markup that is easy to understand for non-technical chat authors and is easy to integrate into your current botmaster stack.\n\nAvailable on npm:\nhttps://www.npmjs.com/package/botmaster-fulfill\n\n Quick start\nAll you need to get started.\n\nnpm install botmaster-fulfill --save\nnpm install botmaster-fulfill-actions --save\n\nconst {outgoing} = require('botmaster-fulfill');\nconst {pause} = require('botmaster-fulfill-actions');\nconst Botmaster = require('botmaster');\nconst botsSettings = require('./my-bots-settings');\nconst botmaster = new Botmaster({botsSettings});\nconst actions = {\n        hi: {\n            controller: () = 'hi there!'\n        },\n        pause\n};\nbotmaster.use('outgoing', outgoing({actions}));\nbotmaster.on('update', bot = bot.sendMessage('hi /pause wait=2500 /What is your name?'));\n\nThis will send two messages \"hi there!\" and \"What is your name?\" with a delay of 2.5 seconds between them.\n\nStandard Actions\n\ntable\nthead\n    thName/ththDescription/ththParameters/ththExample/th\n/thead\ntbody\ntr\n    tdpre&ltpause /&gt/td\n    tdSend the text preceding immediately, then send the text following the tag after a delay of 1 second by default./td\n    td\n         bcodewait/code/b iAttribute Number/i  Specifies how many milliseconds to wait before sending the text following the tag.\n    /td\n    tdpre&ltpause wait=2000 /&gt/pre/td\n/tr\n/tbody\n/table\n\n In-depth\nbotmaster-fulfill extends botmaster with a repertoire of actions that your bots can perform with a declarative and easy to use syntax based on XML. It is a great way to separate business logic (when to do what and where) and functional logic (how to do it).\n\nWhen writing the output of your bots all you have to do is write:\n\n\"ok userName /, im placing your order for you. placeOrder / here you go. \"\n\nHere userName could for example mean get a human readable version of the audience's name.\n\nplaceOrder  does two much more interesting things and demonstrates the power of using markup over a simple field-based JSON payload. First, it sends the rest of the message before the tag (\"ok bob, I'm placing your order for you.\") onwards so that the user knows we are placing his order. Second, it starts placing the order and when its done, it sends the text following it, \"here you go.\"\n\nAnd in order to connect that all you have to do is write in plain js:\n\nconst actions = {\n    // for userName /\n    userName: {\n        controller: function(params) {\n            // return a promise (using an imaginary getUser method)\n            return getUser(params.context.user)\n                .then( function(result) {\n                    return result.user.name\n                    // if name is \"bob\" then the text would be\n                    // \"ok bob, I'm placing your oder for you.\"\n                });\n        }\n    },\n    // for placeOrder /\n    placeOrder: {\n        // replace not just the tag, but the text after too\n        replace: 'after',\n        controller: function(params) {\n            placeOrder(params.context.order)\n                .then( function(result) {\n                    // once the order is placed then send the rest of the message\n                    params.sendMessage(params.after)\n                });\n            // remove the tag and the text after it and send the message (\"ok bob, I'm placing your order for you.\")\n            return '';\n        }\n    }\n}\n\nHow to use the Fulfill API\n\nYou use fulfill by specifying an action spec. At a minimum your spec must specify controller as a javascript function that can return either by callback, promise or even synchronously. The action controller receives a params object which it can use as parameters such as the contents of the tag or data about the chat, which is stored in a variable called context. It can update the context and its return value will replace the tag. If the returned value from an action includes another action, this action will also be evaluated.\n\nOnce fulfill has finished evaluating or actions you get back an updated response string and any context passed in has been modified in place.\n\n Format for the action spec\n\nYou should provide an actions object where the key is the name of the xml element that will be matched. The value should specify another object that has the key controller which as a value should have a function that takes params and an optional callback.\n\nconst actions = {\n// sync burgerImage / example\n  burgerImage: {\n    controller: function() {\n      return \"img url='some/complex/static/path/burger.png'\";\n    }\n  },\n// error first callback modifyOrder style='someStyle'Stuff to order/modifyOrder\n  modifyOrder: {\n    controller: function(params, cb) {\n      myOrderAPI.modify(params.context.orderId, params.content, params.attributes.style, function(err) {\n        if (! err) {\n          cb(null, \"There, consider yourself tomatoed!\");\n        } else {\n          cb(null, \"Sorry I can't modify your order now. Please check again later\")\n        }\n        });\n    }\n  },\n// promise example\n  hi: {\n    controller: function(params) {\n        return new Promise(function(resolve, reject) {\n          resolve(\"hello world\");\n        });\n    }\n  }\n};\n\nMore info on params:\n\nParams argument provides several variables that can control its behavior.\n\nparams.context: a reference to the context object which can be updated or read\nparams.content: the literal text between the xml element opening and closing\nparams.attributes: an object where keys are the name of an attribute against the xml element and the the value is the value of that attribute.\nparams.after: all text and tags before the tag.\nparams.before: all text and tags preceding the tag.\n\n Context:\n\ncontext provides a great deal of control and allows you to pass custom dependencies down to your controllers.\nIt should not be confused with the context variable that your NLU like IBM Conversations uses.\n\nFor example:\nconst context = {\n    myEnvironment: {\n        username, password\n    }\n    myApis: {\n        dbLibrary\n    }\n}\n\nbotmaster.use('outgoing', outgoing({actions, context}))\n\nFulfill will merge these custom context with several standard context objects available when using as part of botmaster.\n\nStandard Context\n\ntable\n    thead\n        tdKey/tdtdDescription/td\n    /thead\n    tbody\n        tr\n            tdparams.update/tdtdBotmaster update object/td\n        /tr\n        tr\n            tdparams.bot/tdtdBotmaster bot object/td\n        /tr\n    /tbody\n/table\n\n{{% notice info %}}\nTo get an NLU's context the update handler or one of the middleware's should have set it in update. So for example your context might be in context.update.context.\n{{% /notice %}}\n\n Getting impatient - emitting updates before fulfill has completed\n\nYou might want to cascade messages and separate them by one minute pauses. Or you want to let your user know that you are working on it. Whatever your use case, emitting multiple updates is not a problem. In botmaster you will also have available context.bot.sendMessage which you can use to send another template response down the pipeline. This will be processed again by fulfill since fulfill is part of the outgoing middleware stack. This is actually advantageous because this way you can be sure that there are no further actions to fulfill from the emitted message.\n\nIf you are not using botmaster you can achieve the same thing by including in the context an emitter which should set off a handler that calls fulfill.\n\nAdditional controller configuration options\n\nBy default, an action modifies the response text by replacing the xml tag with its response inline. This allows multiple actions in a response to not conflict. Note that this default does not allow you to modify any text surrounding the tag.\n\nTake the following example:\noptional / hi how are you / today?\nWith the default mode you can only replace the tag. There are however other modes available that allow you to modify surrounding text.\n\naction.replace:\n\n= 'before' Replace the tag and text before the tag until another tag is reached. In the example above setting you to this mode will have the controller control up to hi how are you /.\n= after Replace the tag and text after the tag until another tag is reached. In the example above setting after to this mode will set the controller to control optional / hi how are you.\n= adjacent Replace the tag and text before and after the tag until other tags are reached. In the example above setting you to this mode will set the controller to control hi how are you / today ?.\n= replaceFunction($, responses) Under the hood fulfill uses cheerio. You can specify a replace function that receives the cheerio object representing the response and the responses. You should return a plain string that will finally go to sendMessage or downstream outgoing middleware.\n\n Using botmaster-fulfill\n\nBotmaster-fulfill exports two functions. The first is fulfill and implements the fulfill API. The second outgoing produces botmaster outgoing middleware.\n\nIf you look at the quick start example the necessary steps are:\n\nrequire the necessary dependencies (the examples gets the outgoing function through destructuring)\nconnect our bots to botmaster\nget actions pass as settings object to outgoing function for it to generate our middleware.\nregister the resulting middleware to botmaster outgoing middlware.\n\nAdditional middleware options\n\nAll of these settings are optional and have reasonable defaults.\n\nsettings.context By default {bot, update} is passed as the context object which is made available to actions. If you want any other variables available in the context assign them as values in the settings.object. bot and update will still be passed into the fulfill context and will overwrite any bot or update in your custom context.\nsettings.updateToInput By default update.message.text is used as the input into response. If this is not acceptable you can define your own function. It will receive an object {bot, update} and expect a string response.\nsettings.responseToUpdate By default update.message.text is replaced with the response from fulfill. It also returns true for sending an update when the response is not empty (''). To define your own setter define a function that accepts update and response, modifies the update in place, and returns true or false whether that update should be sent.\n\n Using standalone without botmaster\n\nconst {fulfill} = require('botmaster-fulfill');\n// the input and context would be from your chatbot, but assume they look like this.\n// also assume actions above\nvar input = \"hi /\";\nvar context = {};\nfulfill(actions, context, input, function(err, response)  {\n    // response =  'hello world!'\n})\n\nSetup hint - drag and drop action modules\n\nYou can drag and drop actions by requiring from an actions folder where you setup your middleware:\nconst actions = require('./actions');\n\nIn your your actions directory then need to include an index.js:\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\nfs.readdirSync(__dirname).forEach(function (file) {\n    if (file.endsWith(\".js\") && file !== \"index.js\")\n        exports[file.substr(0, file.length - 3)] = require(\"./\" + file);\n});\n\nEach action module should export an object that specifies a controller.\n\n Debug\n\nYou can enable debug mode by setting DEBUG = botmaster:fulfill:* in your environment.\n",
        "tags": []
    },
    {
        "uri": "/content/middlewares/official-middleware",
        "title": "Official Middleware",
        "content": "\nMiddleware\n\nMiddleware extends botmaster with additional functionality. Because of their modular nature they are great for extending your bots with functionality very quickly. Read more about how they work here\n\n Official middleware\n\nOutgoing\n\nFulfill - Declarative markup API and engine to integrate internal or external APIs with botmaster.\n npm i botmaster-fulfill -S\n",
        "tags": []
    },
    {
        "uri": "/content/tutorials/index",
        "title": "Tutorials (coming soon)",
        "content": "\n\nTutorials\n\n Watson Conversation\nFulfill\n",
        "tags": []
    },
    {
        "uri": "/content/tutorials/using-fulfill",
        "title": "Using Botmaster Fulfill Middleware",
        "content": "\nUsing Botmaster Fulfill middleware\n\nAlthough many of you will be using Botmaster because of its ability to connect with message sources like Facebook Messenger, it also has a powerful middleware called Botmaster Fulfill. Fulfill helps helps greatly with building more sophisticated bots that need integrations with external data sources and more complex logic. It’s task is to provide a framework for addressing tasks that are outside of the scope of a core NLU or AI engine, so it’s complementary to something like Watson Conversation or Wit.ai.\n\n What can I do with Botmaster Fulfill?\nYou hopefully want to wow your bot’s users with some high-end functionality that gets them hooked on using a conversational interface to get stuff done. If so, you will need to rely on more than pre-canned static replies held within your AI engine – such bots can get pretty boring quite quickly.\n\nConnecting your bot to more dynamic and real-time sources of information is probably high on your priority list. In addition, taking advantage of UI features like buttons and location awareness, might also be things you are interested in. These are the kind of things that Botmaster Fulfill can help with.\n\nTo get specific, here is a set of things that you might use Botmaster Fulfill for:\n\nSpecifying where various types of buttons might be used within the conversation to guide the user’s response.\nSpecifying how a longer conversational response should be broken into a series of shorter messages that appear one-after-the-other in the user’s messaging app, just like we tend to do when texting a friend.\nCalling external API services and integrating the results into the conversation, for example adding a stock quote or weather forecast. Or a call to your organisation’s core systems to retrieve a customer order or balance.\nInitiating transactions such as placing an order or making a payment.\nMaking a time-of-day specific greetings (Good morning, Good afternoon, Good evening, etc).\n\nIn short, anything you need your bot to do that your AI doesn’t, is probably a candidate for Botmast Fulfill.\n\nWhy should I use Botmaster Fulfill?\n“Separation of concerns” is generally considered a good thing. It turns out that in bot design, it’s an especially good thing. Why do we say that?\n\nDesigning your conversational flow and how your bot responds to questions is an analyst-type job - you need people good at understanding the problem domain and how to craft a great conversations. You these people to have a nice life, unencumbered by any technical complexities.\n\nIf your bot needs to invoke programming logic, for example to call an external API and include the results into the bot’s response, you surely want to keep that programming away from your conversational analysts.\n\nHowever, before Botmaster Fulfill it was tricky to keep your conversational design totally separate from your integration logic. Or sometimes you ended up with small pieces of logic buried in your conversational flow who flagged things to some external integration logic - which is basically unmaintainable in the long term.\n\nBotmaster Fulfill solves these problems by providing a clean separation of concerns.  With it, conversational analysts use simple XML tags to markup a bot’s responses. Those tags are interpreted by a series of javascript modules that implement the logic needed. The conversational analyst gets to specify when logic should be called and the engineer gets to separately specify how that logic is implemented….and we achieve a separation of concerns.\n\n How do I use Fulfill in my conversational flow?\nThe beauty of Botmaster Fulfill is that complex logic can be specified by including very simple XML tags within a bot’s response text. For example, in the following dialog response the weather / tag is identified by Botmaster Fulfill and replaced with the result of an API call to a weather forecast service.\nI thought you might like a weather forecaset, so here it is: weather /\n\nWhat is super nice here, is that your dialog designer doesn’t need to worry about how the weather API works or indeed how to get the result of that API call into her conversational response. That’s the engineer’s job - which we will come to shortly.\n\nHere’s another, more complex, example:\n\ngreet /pause /How are you today?buttonsGood,Bad,Indifferent/buttons\n\nThis results in two separate messages being sent:\n\nA message that’s reflective of the time of day, such as “Good morning!” or “Good afternoon.”\nA second message “How are you today?” with three quick-reply buttons Good, Bad, Indifferent.\n\nAs you can hopefully see, multiple XML tags can be included within the same response, building some quite sophisticated responses and integrations. It’s super-simple for the conversational analyst to specify these tags and the programming logic to implement them is totally separated.\n\nSounds great, how do I get started?\nThe implementation of the logic needed to fulfil these XML tags is through what we call a Botmaster Fulfill action. These actions are really just standard javascript code, so any half-decent node coder should be able to get to grips with things pretty quickly.\n\nBut to get us going, we’re first going to use some pre-defined Botmaster Fulfill actions. We’ll move on to making our own custom actions in the next step.\n\nFirst of all install Botmaster Fulfill using: npm install botmaster-fulfill -S\n\nThen, install the pre-defined Botmaster Fulfill actions using: npm install botmaster-fulfill-actions -S\n\nNow add the following code to your Botmaster app.js file:\n\n\tconst {fulfillOutgoingWare} = require('botmaster-fulfill');\n\tconst standardActions = require('botmaster-fulfill-actions');\n\tbotmaster.use('outgoing', fulfillOutgoingWare({\n\t\tstandardActions\n\t}));\n\nNow we’re ready to go! At the time of writing, the standard actions include:\n\n pause / - which breaks the message into two separate messages, one from each side of the pause tag.\n greet tz=\"Europe/London\" / - which returns a location/language relevant greeting such as “Good morning” or “Good evening”, depending on the time of day and the timezone/location specified.\n\nGo ahead and try these out by adding something like the following as a response in whatever dialoging engine you are using:\ngreet /pause /How are you today?\n\nIf you haven’t wired up an AI engine yet, you could just add the following code to your app.js file. If you do that, it doesn’t matter what you type into your bot, you’ll get the same answer - but it does the job of exercising Botmaster Fulfill and its standard actions.\n\nbotmaster.on('update', (bot, update) = {\n\tbot.reply(update, 'greet /pause /How are you today?');\n}\n\nHow cool is that?! The Botmaster project is hoping to expand this set of standard actions, so keep an eye on the Github repo.\n\n But how do I write my own Botmaster Fulfill actions?\nAs we discussed earlier, Botmaster Fulfill actions are just javascript – so, as you’re already using Botmaster, you will already be at least vaguely competent at this task. It’s OK if you’re still at the vague end of the competency spectrum - you can write simple Actions with very basic knowledge.\n\nLets start off by modifying our above code with a super-simple custom action. To do this, we define our custom action by adding the following code after the definition of standardActions in the app.js we used in the last step.\n\nconst checkUserState = {\n\tcontroller: function(params) {\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tresolve('How are you today?');\n\t\t});\n\t}\n};\n\nThis is pretty self-explanatory – checkUserState is the name of the XML tag this code implements. The variable params is just a placeholder for whatever text might be between the open and closing XML tags. In our case this will be empty, because we have a single open/close tag. We return a Javascript Promise that resoles to “How are you today?”, the text that replaces our checkUserState tag in the bot’s reply. Returning a Promise means our code is executed asynchronously - which is pretty handy if you’re calling an external API, for example.\n\nNext, we need to modify our botmaster.use statement to include checkUserState as follows:\n\nactions.checkUserState = checkUserState;\nbotmaster.use('outgoing', fulfillOutgoingWare({\n\tactions\n}));\n\nAnd change our bot reply text to something like the following:\ngreet /pause /checkUserState /\n\nNow this might not be the best of example - it’s a bit overkill to implement a simple question as a Fulfill Action. However, it’s often good to start with something basic so as not to overwhelm ourselves. And “Hello World” has become a bit too ubiquitous for my liking.\n\nUsing Fulfill to create Quick Reply Buttons\nAs we’ve asked a question at this point, wouldn’t it be kind of cool if we provided a Yes and No Quick Reply button as a response? Luckily this is pretty easy to do with Botmaster’s Quick Reply functionality in partnership with Botmaster Fulfill.\n\nTo do this we can add the following Botmaster Fulfill action for buttons:\n\n\tbuttons: {\n\t\tcontroller: (params) = {\n\t\t\tconst buttonTitles = params.content.split('|');\n\t\t\t\tparams.update.message.quick_replies = [];\n\t\t\t\tfor (const buttonTitle of buttonTitles) {\n\t\t\t\t\tparams.update.message.quick_replies.push({\n\t\t\t\t\t\tcontent_type: 'text',\n\t\t\t\t\t\ttitle: buttonTitle,\n\t\t\t\t\t\tpayload: buttonTitle,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t},\n\t\t},\n\t},\n\nAnd update our reply to be:\nhelloWorld /pause /checkUserState /buttonsYes|No/buttons\n\nDo you see what we’re doing here? The button titles are included between the opening/closing buttons tags and separated by “|“. Our controller receives this in the paramas object and splits its contents apart to create a Botmaster quick replies array. You can hopefully see how you might use the same principle to create other types of Botmaster reply objects.\n\n Finding the user’s location\nIf the user is using Facebook Messenger, we can extend the above example to generate a special button asking for the user’s location, which results in us receiving the user’s latitude/longitude.\n\n\tlocButton: {\n\t\tcontroller: (params) = {\n\t\t\tparams.update.message.quick_replies = [];\n\t\t\tparams.update.message.quick_replies.push({\n\t\t\tcontent_type: 'location',\n\t\t});\n\t\treturn '';\n\t\t},\n\t},\n\nand change the returned text to:\n\n\tbotmaster.on('update', (bot, update) = {\n\t\tif (update.message.text != ('Good' || 'Bad' || 'Indifferent')) {\n\t\t\tbot.reply(update, 'greet tz=\"Europe/London\" / userName /pause /How are you today?pause /buttonsGood,Bad,Indifferent/buttons');\n\t\t} else {\n\t\t\tbot.reply(update, 'OK. It would be interesting to know where you are.pause /locButton /');\n\t\t}\n\t});\n\nSo now we have a message returned to us that has the user’s location embedded within in it. How about we use that latitude/longitude to get a weather forecast using a Fulfill action and return that to the user?\n\nCalling an external API in a Fulfill Action\nSo far our examples have been quite trivial. But Fulfill can do some pretty sophisticated things. One thing we find particularly useful is the ability to call an external API and integrate it’s results into the conversational response.\n\nFor this exercise we’re going to integrate the results of a weather forecast API call into our bot’s response.\n\nHere’s the function that calls the weather API service. You’ll need to register here in Bluemix and provide the required userID and password fields to make it work.\n\n\tfunction getWeather(params) {\n\t\tconst lat = params.content.split(',')[0];\n\t\tconst long = params.content.split(',')[1];\n\t\tconst requestOptions = {\n\t\t\turl: 'https://twcservice.mybluemix.net/api/weather/v1/geocode/' + lat + '/' + long + '/forecast/daily/3day.json?language=en-US&units=e',\n\t\t\tauth: {\n\t\t\t\tuser: '[enter user-id here]',\n\t\t\t\tpass: '[enter password here]',\n\t\t\t\tsendImmediately: true,\n\t\t\t},\n\t\t\tjson: true,\n\t\t};\n\t\treturn request(requestOptions)\n\t\t.then((body) = body.forecasts[0].narrative);\n\t}\n\nAnd here’s our weather Action definition:\n\n\tweather: {\n\t\tcontroller: function(params) {\n\t\t\treturn getWeather(params)\n\t\t\t.then(function(result) {\n\t\t\t\tconsole.log(result);\n\t\t\t\treturn 'I thought you might like a weather forecast for that location.pause /' + result;\n\t\t\t})\n\t\t\t.catch(function(err) {\n\t\t\t\tconsole.log(err);\n\t\t\t\treturn 'Sorry, no weather forecast available at the moment.';\n\t\t\t});\n\t\t}\n\t},\n\nIf we update our bot message return logic to the following, we should be able to get a weather forecast sent back to the user when they click on one of the Good, Bad, Indifferent buttons:\n\n\tbotmaster.on('update', (bot, update) = {\n\t\tif (typeof update.message.attachments != 'undefined') {\n\t\t\tif (update.message.attachments[0].type == 'location') {\n\t\t\t\tconst lat = update.message.attachments[0].payload.coordinates.lat;\n\t\t\t\tconst long = update.message.attachments[0].payload.coordinates.long;\n\t\t\t\tbot.reply(update, 'weather' + lat + ',' + long + '/weather');\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (update.message.text != ('Good' || 'Bad' || 'Indifferent')) {\n\t\t\t\tbot.reply(update, 'greet tz=\"Europe/London\" / userName /pause /How are you today?pause /buttonsGood,Bad,Indifferent/buttons');\n\t\t\t} else {\n\t\t\t\tbot.reply(update, 'OK. It would be interesting to know where you are.pause /locButton /');\n\t\t\t}\n\t\t}\n\t});\n\nSo there you have it. Using Botmaster Fulfill to execute standard actions that generate a greeting and break messages up. Using Botmaster Fulfill to generate quick reply buttons, get the user’s location and then call an external weather forecast API. Hopefully your scenario is similar to at least one of these examples and you can find a way of using Fulfill to separate the concerns of your developer and conversational analyst.\n\nIf you want to just skip to a working version of this tutorial, just download this pre-built app.js file.\n\nIf you're inspired by this tutorial to develop your own actions, please consider submitting them to the Botmaster community through a Pull request. We want to foster the development of a library of these functions to simplify everyone’s jobs - and you can help!\n",
        "tags": []
    },
    {
        "uri": "/content/tutorials/watson-conversation",
        "title": "Watson Conversation",
        "content": "\nComing soon!\n",
        "tags": []
    },
    {
        "uri": "/content/updates/changelog",
        "title": "Changelog",
        "content": "\nPATCH 2.2.7\n\nAdd the concept of implements for bot classes. Now every bot object has a bot.implements object that specifies which functionalities are implemented by the bot class. Currently, the values that exist and can be tested against are:\n\nquickReply // for quick replies\nattachment // does it support attachments\ntyping // does it support typing status\n\n PATCH 2.2.6\n\nJust fix a bug in outgoing middleware\n\nPATCH 2.2.5\n\nThis patch adds to the body returned when using any of the bot.sendMessage type helper methods.\n\nNow the body also contains a body.sent_message parameter that is simply the full object that was sent by the bot\n\n PATCH 2.2.4\n\nThis patch allows users to use sendMessage type functions with an optional sendOptions object. Currently, this can be used to bypass outgoing middleware\nwhen sending messages by using the ignoreMiddleware option. Using this looks something like this:\n\nbot.reply(update, 'Hello world!', { ignoreMiddleware: true })\n\nor using a callback function\n\nbot.reply(update, 'Hello world!', { ignoreMiddleware: true }, (body) =\n  console.log(body);\n);\n\nor for buttons\n\nbot.sendDefaultButtonMessageTo(\n  ['button1', 'button2'], sender.user.id, 'click on a button',\n  { ignoreMiddleware: true })\n\nor with cascade messages\n\nbot.sendTextCascadeTo(\n  ['message1', 'message2'], sender.user.id,\n  { ignoreMiddleware: true }, (bodies) = {\n\n  console.log(bodies);\n})\n\nPATCH 2.2.3\n\nThis patch adds support for the bot.sendCascadeTo and bot.sendTextCascadeTo methods. Allowing users to send a cascade of message with just one command rather than having to deal with that themselves. Read more about it here:\n\nhere\n\n PATCH: 2.2.2\n\nThis patch allows users to set the userId from a sender when using the bot socket.io class. socket now needs to be opened with something like this on the client side:\n\nvar socket = io('?botmasterUserId=wantedUserId');\n\nSee updated Botmaster Socket.io bot mini-tutorial here\n\nMINOR: Botmaster 2.2.0\n\nThis minor release allows developers to create news instances of Botmaster without bots settings by writing something like:\n\nconst Botmaster = require('botmaster');\nconst MessengerBot = Botmaster.botTypes.MessengerBot;\n.\n.\nconst botmaster = new Botmaster();\n.\n. // full settings objects omitted for brevity\n.\nconst messengerBot = new MessengerBot(messengerSettings);\nconst slackBot = new SlackBot(slackSettings);\nconst twitterBot = new TwitterBot(twitterSettings);\nconst socketioBot = new SocketioBot(socketioSettings);\nconst telegramBot = new TelegramBot(telegramSettings);\n\nbotmaster.addBot(messengerBot);\nbotmaster.addBot(slackBot);\nbotmaster.addBot(twitterBot);\nbotmaster.addBot(socketioBot);\nbotmaster.addBot(telegramBot);\n\nThis is because it might be viewed as cleaner by some to add bots in the following way rather than doing this in the constructor.\n\n PATCH: Botmaster 2.1.1\n\nThis patch fixes a bug whereby one couldn't instantiate a botmaster object that would use socket.io in all reasonably expected ways. See here for a discussion.\n\nMINOR: Botmaster 2.1.0\n\nThis version adds support for socket.io bots within the botmaster core. This is the last\nbot class that will be in the core\n\n MAJOR: Botmaster 2.0.0\n\nIn this new version, a lot of new things were added to Botmaster. A few others were removed.\n\nBreaking Changes\nIf you were using SessionStore in version 1.x.x, you won't be able to anymore in version 2.x.x. They have been scratched for the far more common middleware design pattern common in so many other frameworks (e.g. express). Middleware can be hooked into right before receiving an update and right before sending out a message. It fits ideally with people wanting to setup session storage at these points.\n\n Adding Slack\nSupport for Slack as the fourth channel supported by Botmaster has been added. Using the Events API, you can now send and receive messages on the platform.\n\nget User info\nIf the platform supports it and the bot class you are using supports it too, you can now use the bot.getUserInfo method to retrieve basic information on a user, including their name and profile pic.\n\n bug fixes\nAs with any release, a bunch of bugfixes were done.\n",
        "tags": []
    },
    {
        "uri": "/content/working-with-botmaster/botmaster-basics",
        "title": "Botmaster Basics",
        "content": "\nBot object\n\nHopefully, by now you've gathered your credentials for at least one platform and got some basic bot running. We remember from the quickstart and the various Setup guides in getting-started that we can start a botmaster project like this:\n\nconst Botmaster = require('botmaster');\n\nconst botmaster = new Botmaster();\n.\n. // full settings objects omitted for brevity\n.\nconst messengerBot = new Botmaster.botTypes.MessengerBot(messengerSettings);\nconst slackBot = new Botmaster.botTypes.SlackBot(slackSettings);\nconst socketioBot = new Botmaster.botTypes.SocketioBot(socketioSettings));\nconst twitterBot = new Botmaster.botTypes.TwitterBot(twitterSettings);\nconst telegramBot = new Botmaster.botTypes.TelegramBot(telegramSettings);\n\nbotmaster.addBot(messengerBot);\nbotmaster.addBot(slackBot);\nbotmaster.addBot(twitterBot);\nbotmaster.addBot(socketioBot);\nbotmaster.addBot(telegramBot);\n.\n.\n.\n\nAs it turns out, bot objects are really the ones running the show in the Botmaster framework. Your botmaster object is simply a central point of control for you to manage all of your bots. Botmaster assumes that most of your bots will have a central bit of code that you don't want to have to replicate for every platform/bot instance. Which should make sense.\n\nAlthough the point of botmaster is for developers to do something like this after declaring the botmaster instance:\n\nbotmaster.on('update', (bot, update) = {\n  // do stuff with your bot and update here\n});\n\nOne could (but shouldn't) just as well do:\n\nmessengerBot.on('update', (update) = {\n  // do stuff with your messenger bot here\n});\n\n// this applies to all the bot objects that would have been declared separately.\n\nI say one shouldn't do that here because the only reason why this callback would work in this situation is because we've already called botmaster.addBot(messengerBot). If we hadn't done that, we would have to mount the messengerBot object onto an express app ourselves. See writing your own bot class to read more on this.\n\nThe update object in the event callback is the same as the botmaster update one you would get in the botmaster update callback. Of course the messenger.on(...) piece of code would only apply to your messengerBot instance and not the others.\n\nAs seen, bot instances can be accessed directly within an update event. Because you might want to act differently on bots of a certain type or log information differently based on type, every bot comes with a bot.type parameter that is one of: messenger, slack, twitter, socketio, telegram or whatever third-party bot class you might have installed or created.\n\nIt is important to note here, that you can have multiple bot objects for a certain type. I'm sure you can find reasons for why you would want to do this. This is important to mention, as you might have, say, 2 bots of type messenger dealt with via Botmaster. You might want to do platform specific code by doing the following:\n\nbotmaster.on('update', (bot, update) = {\n  if (bot.type === 'messenger' {\n    // do messenger specific stuff\n    return;\n  })\n})\n\nThen you might want to do bot object specific code. You would do this as such:\n\nbotmaster.on('update', (bot, update) = {\n  if (bot.type === 'messenger' {\n    // do messenger specific stuff\n    if (bot.id === 'YOURBOTID') {// this will be the user id of bot for messenger\n      // do bot object specific stuff\n      return;\n    }\n  })\n})\n\nOr if you declared your bots and botmaster as in the beginning of this section, you might have done the following:\n\nconst Botmaster = require('botmaster');\nconst botmaster = new Botmaster();\n// These are some of the bot classes that come with Botmaster\nconst Messengerbot = Botmaster.botTypes.MessengerBot;\nconst SlackBot = Botmaster.botTypes.SlackBot;\nconst TwitterBot = Botmaster.botTypes.TwitterBot;\n.\n. // full settings objects omitted for brevity\n.\nconst messengerBot1 = new MessengerBot(messengerSettings1);\nconst messengerBot2 = new MessengerBot(messengerSettings2);\nconst slackBot = new SlackBot(slackSettings);\nconst twitterBot = new TwitterBot(twitterSettings);\n\nbotmaster.addBot(messengerBot);\nbotmaster.addBot(slackBot);\nbotmaster.addBot(twitterBot);\n\nbotmaster.on('update', (bot, update) = {\n  if (bot.type === 'messenger' {\n    // do messenger bot specific stuff\n\n    if (bot === messengerBot1) { // without using ids\n      // do messengerBot1 specific stuff\n    }\n    return;\n  })\n})\n\n{{% notice warning %}}\nBotmaster does not assure you that the id parameter of the bot object will exist upon instantiation. the id is only assured to be there once an update has been received by the bot. This is because some ids aren't known until botmaster knows 'who' the message was sent to (i.e. what id your bot should have).\n{{% /notice %}}\n\nI'll note quickly that each bot object created comes from one of the various bot classes as seen above. They act in the same way on the surface (because of heavy standardization), but have a few idiosynchrasies here and there.\n\nAlso useful to note is that you can access all the bots added to botmaster by doing botmaster.bots. you can also use botmastet.getBot or botmaster.getBots to get a specific bot (using type or id);\n\nIt is important to take note of the addBot syntax as you can create your own Bot class that extends the Botmaster.botTypes.BaseBot class. For instance, you might want to create your own class that supports your pre-existing messaging standards. Have a look at the working with a botmaster supported bot class  documentation to learn how to do this.\n\n Settings\n\nBotmaster can be started with a so-called botmasterSettings object. It has the following parameters:\nThe botmasterSettings object has the following parameters:\n\n| Parameter | Description\n|--- |---\n| port  | (optional) The port to use for your webhooks (see webhooks to understand more about webhooks). This will only be used if the app parameter is not provided. Otherwise, it will be ignored\n| app  | (optional) An express.js app object to mount the webhookEnpoints onto. If you choose to do this, it is assumed that you will be starting your own express server and this won't be done by Botmaster. Unless you also specify a server parameter, botmaster.server will be undefined\n\n{{% notice warning %}}\nbotsSettings and server parameters have been deprecated in version 2.2.3. Please use addBot instead of botsSettings and set the socketio server in your socketSettings object.\n{{% /notice %}}\n\nUsing botsSettings would look something like this if you want to set the port:\n\nconst Botmaster = require('botmaster');\n\nconst botmasterSettings = {\n  // by default botmaster will start an express server that listens on port 3000\n  // you can pass in a port argument here to change this default setting:\n  port: 3001\n}\n\nconst botmaster = new Botmaster(botmasterSettings);\n\n.\n. // rest of code adding bots to botmaster etc\n.\n\n{{% notice info %}}\nPlease note, unless you are passing in an app object to the settings, it is assumed that you don't want to deal with anything relating to an http server. That is, botmaster will create an express server under the hood and expose both: botmaster.app and botmaster.server.\n{{% /notice %}}\n\nSetting botmasterSettings to use Botmaster with your own express() app\n\nHere's an example on how to do so if you are setting your credentials in your environment variables:\n\nconst express = require('express');\nconst Botmaster = require('botmaster');\n\nconst app = express();\nconst port = 3000;\nconst botmasterSettings = { app: app };\nconst botmaster = new Botmaster(botmasterSettings);\n\n// settings and adding those to botmaster\nconst telegramSettings = {\n  credentials: {\n    authToken: process.env.TELEGRAM_TOKEN,\n  },\n  webhookEndpoint: '/webhook1234/',\n};\n\nconst messengerSettings = {\n  credentials: {\n    verifyToken: process.env.MESSENGERVERIFYTOKEN,\n    pageToken: process.env.MESSENGERPAGETOKEN,\n    fbAppSecret: process.env.FACEBOOKAPPSECRET,\n  },\n  webhookEndpoint: '/webhook1234/',\n};\n\nconst messengerBot = new Botmaster.botTypes.MessengerBot(messengerSettings);\nconst telegramBot = new Botmaster.botTypes.TelegramBot(telegramSettings);\n\nbotmaster.addBot(messengerBot);\nbotmaster.addBot(telegramBot);\n////////\n\nbotmaster.on('update', (bot, update) = {\n  bot.sendMessage({\n    recipient: {\n      id: update.sender.id,\n    },\n    message: {\n      text: 'Well right back at you!',\n    },\n  });\n});\n\n// start server on the specified port and binding host\napp.listen(port, '0.0.0.0', () = {\n  // print a message when the server starts listening\n  console.log(Running App on port: ${port});\n});\n\n Events\n\nBotmaster is built on top of the EventEmitter node.js class. Which means it can emit events and most importantly for us here, it can listen onto them. By doing any of the following:\n\nbotmaster.on('server running', (message) = {\n  console.log(message);\n});\n\nbotmaster.on('update', (bot, update) = {\n  console.log(bot.type);\n  console.log(update);\n});\n\nbotmaster.on('error', (bot, err) = {\n  console.log(bot.type);\n  console.log(err.stack);\n});\n\nThese are the only four listeners that you can listen onto in botmaster. Let's go though them briefly:\n\nserver running\n\nThis event will be emitted only if you are not managing your own server (i.e. you started botmaster without setting the app parameter). It is just here to notify you that the server has been started. You don't necessarily need to use it. But you might want to do things at this point.\n\n update\n\nThis is really where all the magic happens. Whenever a message (update in Botmaster semantic) is sent into your application. Botmaster will parse it and format it into its [FB Messenger] standard. Along with it, you will get a bot object which is the underlying object into which the message was sent. Note that the updates are standardized as well as the methods to use from the bot object (i.e. sending a message). Read further down to see how those two objects work.\n\nerror\n\nThis event is thrown whenever an error internal to Botmaster occurs. I.e. if for some reason a misconfigured message was sent in. Or if some other kind of error occurred directly within Botmaster. It is good to listen onto this event and keep track of potential errors. Also, if you code an error within botmaster.on, and don't catch it, it will be caught by Botmaster and emitted in to error. So like this you have full control of what is going on and can log everything straight from there.\n\n Message/Update format\n\nStandardization is at the heart of Botmaster. The framework was really created for that purpose. This means that messages coming from any platform have to have the same format.\n\nIn order to do that, the Facebook Messenger message format was chosen and adopted. This means that when your botmaster object receives an 'update' event from anywhere, you can be sure that it will be of the same format as a similar message that would come from Facebook Messenger.\n\nIncoming update\n\nTypically, it would look something like this for a message with an image attachment. Independent of what platform the message comes from:\n\n{\n  raw: platformspecificraw_update,\n  sender: {\n    id: idofsender\n  },\n  recipient: {\n    id: idofthe_recipent // will typically be the bot's id\n  },\n  timestamp: unixmilisecondstimestamp,\n  message: {\n    mid: message_id,\n    seq: messagesequenceid,\n    attachments: [\n      {\n        type: 'image',\n        payload: {\n          url: 'https://scontent.xx.fbcdn.net/v/.....'\n        }\n      }\n    ]\n  }\n};\n\nThis allows developers to handle these messages in one place only rather than doing it in multiple places. For more info on the various incoming messages formats, read the messenger bot doc on webhooks at: https://developers.facebook.com/docs/messenger-platform/webhook-reference/message-received.\n\nCurrently, you will only get updates for Messages (and not delivery, echo notification etc) for all platforms. On Messenger, it is assumed that you don't want to get updates for delivery, read and echo. This can't be turned on at the moment, but will be in later versions as it might be a requirement.\n\n Note on attachment types and conversions\nAttachment type conversion on incoming updates works as such for Twitter:\n\n| Twitter Type | Botmaster conversion\n|--- |---\n| photo | image\n| video  | video\n| gif  | video\n\n!!!Yes gif becomes a video. because Twitter doesn't actually use gifs the way you would expect it to. It simply loops over a short .mp4 video.\n\nAlso, here's an important caveat for Twitter bot developers who are receiving attachments. Image links that come in from the Twitter API will be private and not public, which makes using them quite tricky. You might need to make authenticated requests to do so. The twitterBot objects you will receive in the update will have a bot.twit object. Documentation for how to use this is available here.\n\nReceiving and sending attachments [the Botmaster way] is not yet supported on Slack as of version 2.2.3. However, Slack supports url unfurling (meaning if you send images and other types of media urls in your message, this will be shown in the messages and users won't just see a url). Also, because of how Botmaster is built (i.e. keep all information from the original message) you can find all the necessary information in the update.raw object of the update.\n\nAttachment type conversion works as such for Telegram:\n\n| Telegram Type | Botmaster conversion\n|--- |---\n| audio | audio\n| voice  | audio\n| photo  | image\n| video  | video\n| location  | location\n| venue  | location\n\ncontact attachment types aren't supported in Messenger. So in order to deal with them in Botmaster, you will have to look into your update.raw object which is the standard Telegram update. You will find your contact object in update.raw.contact.\n\nAlso, concerning location and venue attachments. The url received in Botmaster for Telegram is a google maps one with the coordinates as query parameters. It looks something like this: https://maps.google.com/?q=lat,long\n\nA few of you will want to use attachments with your socket.io bots. Because the Botmaster message standard is the Facebook Messenger one, everything is URL based. Which means it is left to the developer to store both incoming and outgoing attachments. A tutorial on how to deal with this will be up soon in the Tutorials section.\n\nOutgoing messages\n\nAgain, outgoing messages are expected to be formatted like messages the Messenger platform would expect. They will typically look something like this for a text message:\n\nconst message = {\n  recipient: {\n    id: update.sender.id,\n  },\n  message: {\n    text: 'Some arbitrary text of yours'\n  },\n}\n\nand you would use this as such in code:\n\nbotmaster.on('update', (bot, update) = {\n  const message = {\n    recipient: {\n      id: update.sender.id,\n    },\n    message: {\n      text: 'Some arbitrary text of yours'\n    },\n  };\n  bot.sendMessage(message);\n});\n\ntypically, you would want to perform some action upon confirmation that the message was sent or catch a potential error. doing so is done like this:\n\nbotmaster.on('update', (bot, update) = {\n  .\n  .\n  bot.sendMessage(message)\n\n  .then((body) = {\n    console.log(body);\n  })\n\n  .catch((err) = {\n    console.log(err.message);\n  })\n});\n\nThe body part of the response has the following structure:\n\n| Argument | Description\n|--- |---\n| raw | raw response body (response from the platform).\n| recipient_id | id of user who sent the message\n| message_id | id of message that was just sent\n| sent_message | full object that was just sent after going through all the outgoing middlewares\n\nYou can also opt to use callbacks rather than promises and this would work as such:\n\nbotmaster.on('update', (bot, update) = {\n  .\n  .\n  bot.sendMessage(message, (err, body) = {\n    if (err) {\n      return console.log(err.message);\n    }\n\n    console.log(body);\n  });\n});\n\nTypically, this method (and all its accompanying helper ones that follow) will hit all your setup outgoing middleware (read more about middleware here if you don't know about them yet). If you want to avoid that and ignore your setup middleware in certain situations, do something like this:\n\nbotmaster.on('update', (bot, update) = {\n  .\n  .\n  bot.sendMessage(message, { ignoreMiddleware: true })\n});\n\nAnd its signature is as follows:\n\nbot.sendMessage\n\n| Argument | Description\n|--- |---\n| message | a full valid messenger message object.\n| sendOptions | (optional) an object containing options regarding the sending of the message. One of those options is: ignoreMiddleware.\n| cb | (optional) callback function if you don't want to use botmaster with promises.\n\nAs you can see, the sendMessage method used is used directly from the bot object and not using the botmaster one.\n\nBecause you might not always want to code in a complex json object just to send in a simple text message or photo attachment, Botmaster comes with a few helper methods that can be used to send messages with less code:\n\nbot.sendMessageTo\n\n| Argument | Description\n|--- |---\n| message | an object without the recipient part. In the previous example, it would be message.message.\n| recipientId  | a string representing the id of the user to whom you want to send the message.\n| sendOptions | (optional) an object containing options regarding the sending of the message. One of those options is: ignoreMiddleware.\n| cb | (optional) callback function if you don't want to use botmaster with promises.\n\nbot.sendTextMessageTo\n\n| Argument | Description\n|--- |---\n| text | just a string with the text you want to send to your user\n| recipientId  | a string representing the id of the user to whom you want to send the message.\n| sendOptions | (optional) an object containing options regarding the sending of the message. One of those options is: ignoreMiddleware.\n| cb | (optional) callback function if you don't want to use botmaster with promises.\n\nTypically used like so to send a text message to the user who just spoke to the bot:\n\nbotmaster.on('update', (bot, update) = {\n  bot.sendTextMessageTo('something super important', update.sender.id);\n});\n\nbot.reply\n\n| Argument | Description\n|--- |---\n| update | an update object with a valid update.sender.id.\n| text  | just a string with the text you want to send to your user\n| sendOptions | (optional) an object containing options regarding the sending of the message. One of those options is: ignoreMiddleware.\n| cb | (optional) callback function if you don't want to use botmaster with promises.\n\nThis is is typically used like so:\n\nbotmaster.on('update', (bot, update) = {\n  bot.reply(update, 'something super important!');\n});\n\n Attachments\n\nbot.sendAttachmentTo\n\nWe'll note here really quickly that Messenger only takes in urls for file attachment (image, video, audio, file). Most other platforms don't support sending attachments in this way. So we fall back to sending the url in text which really results in a very similar output. Same goes for Twitter that doesn't support attachments at all.\n\n| Argument | Description\n|--- |---\n| attachment | a valid Messenger style attachment. See here for more on that.\n| recipientId  | a string representing the id of the user to whom you want to send the message.\n| sendOptions | (optional) an object containing options regarding the sending of the message. One of those options is: ignoreMiddleware.\n| cb | (optional) callback function if you don't want to use botmaster with promises.\n\nThis is the general attachment sending method that will always work for Messenger but not necessarily for other platforms as Facebook Messenger supports all sorts of attachments that other platforms don't necessarily support. So beware when using it. To assure your attachment will be sent to all platforms, use bot.sendAttachmentFromURLTo.\n\nThis is typically used as such for sending an image url.\n\nbotmaster.on('update', (bot, update) = {\n  const attachment = {\n    type: 'image'\n    payload: {\n      url: \"some image url you've got\",\n    },\n  };\n  bot.sendAttachment(attachment, update.sender.id);\n});\n\nbot.sendAttachmentFromURLTo\n\nJust easier to use this to send standard url attachments. And URL attachments if used properly should work on all out-of-the-box platforms:\n\n| Argument | Description\n|--- |---\n| type | string representing the type of attachment (audio, video, image or file)\n| url  | the url to your file\n| recipientId  | a string representing the id of the user to whom you want to send the message.\n| sendOptions | (optional) an object containing options regarding the sending of the message. One of those options is: ignoreMiddleware.\n| cb | (optional) callback function if you don't want to use botmaster with promises.\n\nThis is typically used as such for sending an image url.\n\nbotmaster.on('update', (bot, update) = {\n  bot.sendAttachmentFromURLTo('image', \"some image url you've got\", update.sender.id);\n});\n\nStatus\n\nbot.sendIsTypingMessageTo\n\nTo indicate that something is happening on your bots end, you can show your users that the bot is 'working' or 'typing' something. to do so, simply invoke sendIsTypingMessageTo.\n\n| Argument | Description\n|--- |---\n| recipientId  | a string representing the id of the user to whom you want to send the message.\n| sendOptions | (optional) an object containing options regarding the sending of the message. One of those options is: ignoreMiddleware.\n| cb | (optional) callback function if you don't want to use botmaster with promises.\n\nIt is used as such:\n\nbotmaster.on('update', (bot, update) = {\n  bot.sendIsTypingMessageTo(update.sender.id);\n});\n\nIt will only send a request to the platforms that support it. If unsupported, nothing will happen.\n\n Buttons\n\nButtons will almost surely be part of your bot. Botmaster provides a method that will send what is assumed to be a decent way to display buttons throughout all platforms.\n\nbot.sendDefaultButtonMessageTo\n\n| Argument | Description\n|--- |---\n| buttonTitles | array of button titles (no longer than 10 in size).\n| recipientId  | a string representing the id of the user to whom you want to send the message.\n| textOrAttachment  | (optional) a string or an attachment object similar to the ones required in bot.sendAttachmentTo. This is meant to provide context to the buttons. I.e. why are there buttons here. A piece of text or an attachment could detail that. If not provided,  text will be added that reads: 'Please select one of:'. This is only optional if none of sendOptions and cb is specified\n| sendOptions | (optional) an object containing options regarding the sending of the message. One of those options is: ignoreMiddleware.\n| cb | (optional) callback function if you don't want to use botmaster with promises.\n\nThe function defaults to sending quick_replies in Messenger, setting Keyboard buttons in Telegram, buttons in Slack and simply prints button titles one on each line in Twitter as it doesn't support buttons. The user is expecting to type in their choice in Twitter. In the socketio implementation, the front-end/app developer is expected to write the code that would display the buttons on their front-end.\n\nIt is used as such:\n\nbotmaster.on('update', (bot, update) = {\n  const buttonArray = ['button1', 'button2'];\n  bot.sendDefaultButtonMessageTo(buttonArray, update.sender.id,\n    'Please select \"button1\" or \"button2\"');\n});\n\n{{% notice warning %}}\nIf you will be using either of sendOptions or cb, you will need to specify textOrAttachment.\n{{% /notice %}}\n\nCascade\n\nIn order to send a cascade of messages (i.e. multiple messages one after another), you might want to have a look at both of these methods:\n\nbot.sendCascadeTo\n\n| Argument | Description\n|--- |---\n| messageArray | Array of messages in a format as such: [{text: 'something'}, {message: someMessengerValidMessage}] read below to see valid keys.\n| recipientId  | a string representing the id of the user to whom you want to send the message.\n\nAs you might have guessed, Botmaster assures you that the objects in the messageArray will be sent in order. Furthermore, the objects of the messageArray must be of a certain form where valid params are the following:\n\n{\n  raw: SOMEVALIDRAW_MESSAGE, // the same object as one you would send with sendRaw()\n  message: SOMEVALIDMESSENGER_MESSAGE, // the same object as one you would send with sendMessage() (i.e. the recipientId won't be taken into account!)\n  buttons: SOMEARRAYOFBUTTONTITLES, // same as what you would do with: sendDefaultButtonMessageTo. If you will be sending attachments/text alongside it, add them in the following fields. If both are present, the attachment will be used.\n  attachment: SOME_ATTACHMENT, // same object format as in: sendAttachmentTo()\n  text: 'some text', // same as when using sendTextMessageTo()\n  isTyping: SOMETRUTHYVALUE, // will call sendIsTypingMessageTo() on the recipientId used in sendCascade.\n}\n\n{{% notice info %}}\nIt is important to note that all these parameters will be hit in the shown order if present. I.e. if raw is present, message will not be hit nor will buttons be hit etc.\n{{% /notice %}}\n\nYou could typically use this as such:\n\nbotmaster.on('update', (bot, update) = {\n  const rawMessage = SOMERAWPLATFORM_MESSAGE;\n\n  const fullMessage = {\n    recipient: {\n      id: someUserId, // note that I am not using update.sender.id on purpose here, so as to show that this overrides the recipientId from the sendCascade Method\n    },\n    message: {\n      text: 'Some arbitrary text of yours'\n    },\n  };\n\n  const buttonsArray = ['button1', 'button2'];\n  const textForButtons = 'Please select one of the two buttons';\n\n  const someText = 'some text message after all this';\n\n  bot.sendCascadeTo([\n    { raw: rawMessage},\n    { message: fullMessage },\n    { isTyping: true },\n    { buttons: buttonsArray,\n      text: textForButtons\n    },\n    { isTyping: true },\n    { text: someText },\n  ], update.sender.id)\n});\n\nWhere our recipientId is set to update.sender.id.\n\nIn this example, the bot will send a rawMessage and then a botmaster supported message to the platform (both these messages will not take into consideration the recipientId (update.sender.id) set in sendCascade). Then it will send a button message and then a standard text message. Both these last messages will be sent to the specified recipientId (again, update.sender.id). Note that before each message sent to the recipient, I also send an 'isTyping' message to the recipient. I purposefully do not do so for the first two messages as it is assumed here that those messages are not being sent to the recipient, but to some other user.\n\nbot.sendTextCascadeTo\n\n| Argument | Description\n|--- |---\n| textMessageArray | Array of strings that you want to send to the user in sequences.\n| recipientId  | a string representing the id of the user to whom you want to send the message.\n\nThis method is really just a helper for calling bot.sendCascadeTo. It just allows developers to use the method with an array of texts rather than an array of objects.\n\nSomething like this will do:\n\nbot.sendTextCascadeTo(['message1', 'message2'], user.sender.id);\n\nsendOptions is an optional argument that can take in the following parameters (for now)\n\n| key/option |  Description\n|--- |---\n| ignoreMiddleware | outgoing middleware will not be hit if this parameter is set to true (or any truthy value)\n\nIf you want to learn more about middleware and why you might want to use any of these options, read more about middleware here\n",
        "tags": []
    },
    {
        "uri": "/content/working-with-botmaster/index",
        "title": "Working with Botmaster",
        "content": "\nWorking with Botmaster\n\n Botmaster Basics\nMiddleware\n Writing your Own Botmaster Class\n",
        "tags": []
    },
    {
        "uri": "/content/working-with-botmaster/middleware",
        "title": "Middleware",
        "content": "\nMiddleware in Botmaster is designed to work similarly to  what you would expect in an express.js app. However, you might not have used express and they work slightly differently, so here's a writeup of how they work.\n\nGenerally, middleware allows developers to do some preprocessing on some received data before performing some main action based on what was received (like sending a response to the client that made the request). Because the term pre-processing is fairly vague and can be interpreted as broad, developers often end up having the main parts of their code within middleware. Botmaster is no different. Here's a typical diagram flow showing how it looks like under the hood.\n\nBecause Botmaster is a chatbot framework and not a web app framework, we go on and define two different types of middleware: incoming and outgoing middleware. Incoming middleware is akin to what you would have in a standard express middleware (if you have experience with express), whereas outgoing middleware will act on your response object.\n\nHere is the signature of botmaster.use\n\n| Parameter | Description\n|--- |---\n| middlewareType  | either 'incoming' or 'outgoing' depending on what middleware you are setting up.\n| options | (optional) set options for when to activate the middleware. Currently only supports a type parameter that takes in a space separated string of platform names (names are defined in the bot classes and values are set in bot.type)\n| middlewareCallback | The actual middleware function that will be called. It is of type: function(bot, update, next) on incoming and function(bot, message, next) on outgoing\n\nIncoming middleware\n\nAs mentioned briefly above, incoming middleware in Botmaster is similar to what you would have in express middleware and can be used similarly. They are all called in order of declaration upon receiving an update before entering the on('update'...) function.\n\n Basic incoming middleware example\n\nHere is a very simple example of how one would go on and use incoming middleware:\n\nbotmaster.use('incoming', (bot, update, next) = {\n  // assumed here that some weather API is queried to get that weatherInformation\n  update.weatherInfo = {\n    weather: 23,\n    unit: 'celcius',\n  }\n  next(); // !! always call next when done to go to next middleware function\n});\n\nbotmaster.on('update', (bot, update) = {\n  if (update.weatherInfo.weather  20) {\n    bot.reply(update, 'the weather is warm');\n  } else {\n    bot.reply(update, 'the weather is mild');\n  }\n});\n\nThis is a very basic example. But hopefully, it gets the message through of how and why you would use incoming middleware. Clearly, anything can be done in a middleware function, like calling external APIs etc. You are encouraged to do so really.\n\nBasic incoming middleware example with structure\n\nIn practice, your middleware code will really live within separate files that you would \"require\" within your main \"app.js\" file. That means that the previous example will have a tree structure similar to the following:\n\n├── app.js\n└── middleware\n    ├── incoming\n    │   ├── weather.js\n    │   └── index.js\n    └── outgoing // no outgoing middleware in this example\n        └── index.js // this will remain an empty file for now\n\nThis is only a suggested structure (the one I use). Feel free to come up with a different, potentially better, structure that suits you better.\n\nThat means that the previous example's code will probably look more like this:\n\nmiddleware/incoming/weather.js\n\n// using eslint disallowFunctionDeclarations here. Read here: https://github.com/airbnb/javascriptfunctions to see why I use this syntax rather than the standard function updateText(bot,  message, next) one.\nconst addWeatherInfoToUpdate = function addWeatherInfoToUpdate(bot, update, next) {\n  update.weatherInfo = {\n    weather: 23,\n    unit: 'celcius',\n  }\n  next();\n}\n\nmodule.exports = {\n  addWeatherInfoToUpdate, // using shorthand here\n}\n\nmiddleware/incoming/index.js\nconst weather = require('./weather');\n\nmodule.exports = {\n  weather,\n};\n\napp.js\n\nconst incomingMiddleware = require('./middleware/incoming');\n\nbotmaster.use('incoming', incomingMiddleware.weather.addWeatherInfoToUpdate);\n\nbotmaster.on('update', function(bot, update){\n  if (update.weatherInformation.weather  20) {\n    bot.reply(update, 'the weather is warm');\n  } else {\n    bot.reply(update, 'the weather is mild');\n  }\n});\n\nComplete incoming middleware example with structure\n\nNow if I wanted to, say, add a couple of user info related middleware functions including a middleware function that would get hit only on Facebook Messenger bots (bots of type messenger), using the same base structure, and updating it as follows:\n\n├── app.js\n└── middleware\n    ├── incoming\n    │   ├── weather.js\n    │   ├── user_info.js\n    │   └── index.js\n    └── outgoing\n        └── index.js\n\nI would do the following:\n\ncreate the file middleware/incoming/user_info.js as follows:\n\nmiddleware/incoming/user_info.js\n\nconst addUserInfoToUpdate = function addUserInfoToUpdate(bot, update, next) {\n  bot.getUserInfo(update.sender.id)\n\n  .then((userInfo) = {\n    update.userInfo = userInfo;\n    next(); // next is only called once the user information is gathered\n  });\n}\n\nconst addUsernameToUpdate = function addUsernameToUpdate(bot, update, next) {\n  update.username = 'there';\n\n  if (update.userInfo) {\n    update.username = update.userInfo.first_name;\n  }\n  next();\n}\n\nmodule.exports = {\n  addUserInfoToUpdate,\n}\n\nThen update middleware/incoming/index.js and app.js to look like this respectively:\n\nmiddleware/incoming/index.js\n\nconst weather = require('./weather');\nconst userInfo = require('./user_info');\n\nmodule.exports = {\n  weather,\n  userInfo,\n};\n\napp.js\n\nconst incomingMiddleware = require('./middleware/incoming');\n\nbotmaster.use('incoming', incomingMiddleware.weather.addWeatherInfoToUpdate);\nbotmaster.use('incoming', { type: 'messenger' },\n              incomingMiddleware.userInfo.addUserInfoToUpdate);\nbotmaster.use('incoming', incomingMiddleware.userInfo.addUsernameToUpdate);\n\nbotmaster.on('update', (bot, update) = {\n  if (update.weatherInformation.weather  20) {\n    bot.reply(update, Hi ${update.username}, the weather is warm);\n  } else {\n    bot.reply(update, Hi ${update.username}, the weather is warm);\n  }\n});\n\nIn this example, I expand on the previous example and setup two new middleware functions. One that will be called only on bots of type messenger and the other one on all bots. The first one gets the information available on the user if the bot is of type messenger. The second one then sets the update.username according to whether it finds a name or not. As mentioned, they are called in order of declaration.\n\nIt should be clear by now that this reads much clearer than the previous example. Simply by reading the app.js file I can have an idea of what is going on in the code. Cleary, some weather information and user information is added to the update object that information is then used to customize the text returned to the user.\n\nNow that we've had a look at incoming middleware, let's have a look at how outgoing middleware works.\n\n Outgoing middleware\n\nsimilar to the incoming middleware, the outgoing middleware is called in order of declaration. However, it is called on every message object sent by you the developer. To illustrate this, here's an example:\n\nBasic example\n\nbotmaster.on('update', function(bot, update){\n  bot.reply(update, 'Hello world!') // using a helper function to send text message\n});\n\nbotmaster.use('outgoing', function(bot, message, next) {\n  console.log(message); // this is a full valid messenger object.\n\n  message.message.text = \"Hello you!\";\n  next();\n});\n\nIn this example, the first three lines are what you would expect if you were simply trying to reply \"Hello world\" to any message. However, if you try this out, you'll see that you get a \"Hello you!\" text message back. Indeed, our middleware, aside from printing the message object to show you what it looks like, replaces the text with \"Hello you\".\n\nThis is really what you'll want to be doing within outgoing middleware. First use one of the Botmaster helper functions to send a message, then edit it in your outgoing middleware functions. Botmaster simply creates the valid [messenger compatible] message object before hitting the outgoing middleware where you can play with this.\n\n Basic example with structure\n\nAs in the incoming middleware example, in practice, your middleware code will really live within separate files that you would \"require: within your main \"app.js\" file. Using a structure similar to the one used in the incoming middleware example. We look at something like this:\n\n├── app.js\n└── middleware\n    ├── incoming // no incoming middleware in this example\n    │   └── index.js // this will remain an empty file for now\n    └── outgoing\n        ├── message_transformers.js\n        └── index.js\n\nWhere your code will look something like this\nThat means that the previous example will probably look more like this:\n\nmiddleware/outgoing/message_transformers.js\n\n// using eslint disallowFunctionDeclarations here. Read here: https://github.com/airbnb/javascript#functions to see why I use this syntax rather than the standard function updateText(bot,  message, next) one.\nconst changeText = function changeText(bot, message, next) { // using\n  console.log(message); // this is a full valid messenger object.\n\n  message.message.text = 'Hello you!';\n  next();\n}\n\nmodule.exports = {\n  changeText, // using shorthand here\n}\n\nmiddleware/outgoing/index.js\nconst messageTransformers = require('./message_transformers');\n\nmodule.exports = {\n  messageTransformers,\n};\n\napp.js\n\nconst outgoingMiddleware = require('./middleware/outgoing');\n\nbotmaster.on('update', function(bot, update){\n  bot.reply(update, 'Hello world!') // using a helper function to send text message\n});\n\nbotmaster.use('outgoing', outgoingMiddleware.messageTransformers.updateText);\n\nThis might seem like slight overkill at this point because of how trivial of an example this is. But this adds clear structure to our project and when reading our app.js file we can already know what is going on. It also makes it very clear regarding what is going on if you were to add another middleware function right after the updateText one.\n\nComplete outgoing middleware example with structure\n\nTaking this one step further, you can do something like the following to, say, send buttons without using the builtin sendDefaultButtonMessageTo method. We'll keep our structure and simply update the files to look like this:\n\nmiddleware/outgoing/message_transformers.js\nconst changeText = function changeText(bot, message, next) { // using\n  console.log(message);\n\n  if (message.message.text === 'Thank you') {\n    message.message.text = 'Thanks';\n  }\n\n  next();\n}\n\nconst addButtonsToMessage = function addButtonsToMessage(bot, message, next) {\n  const text = message.message.text;\n\n  const buttonsRegexObject = text.match(/&\\[.+]/);\n  if (buttonsRegexObject) {\n    const buttonTitles = JSON.parse(buttonsRegexObject[0].substring(1));\n    const cleanedText = text.replace(buttonsRegexObject[0], '');\n\n    message.message.quick_replies = [];\n    for (const buttonTitle of buttonTitles) {\n      message.message.quick_replies.push({\n        content_type: 'text',\n        title: buttonTitle,\n        payload: buttonTitle,\n      });\n    }\n\n    message.message.text = cleanedText;\n  }\n\n  next();\n}\n\nmodule.exports = {\n  changeText, // using shorthand here\n  addButtonsToMessage,\n}\n\nThis simple addButtonsToMessage function simply uses regular expressions to see if the text contains any bit of text that looks anything like the following: '[\"Button1\",\"Button2\"]'. If any such string is found, it then proceeds to add a quick_replies component to your message object and update the text to remove those button mentions. We next have a look at app.js that also has to be transformed:\n\napp.js\n\nconst outgoingMiddleware = require('./middleware/outgoing');\n\nbotmaster.on('update', function(bot, update){\n  bot.sendTextCascadeTo(['Hi there, I`m about to ask you to press buttons:',\n                         'Please press any of: [\"Button1\",\"Button2\"]',\n                         'Thank you']);\n});\n\nbotmaster.use('outgoing', outgoingMiddleware.messageTransformers.updateText);\nbotmaster.use('outgoing', outgoingMiddleware.messageTransformers.addButtonsToMessage);\n\nNow this will work great. But actually, what i want to do is show the user a typing indicator right before sending every message that goes out. Because I'm using a sendCascade function, namely, sendTextCascadeTo, the best way to do so is to do this within an outgoing middleware function. Here's how we can edit app.js to achieve this goal:\n\napp.js\n\nconst outgoingMiddleware = require('./middleware/outgoing');\n\nbotmaster.on('update', function(bot, update){\n  bot.sendTextCascadeTo(['Hi there, I`m about to ask you to press buttons:',\n                         'Please press any of: [\"Button1\",\"Button2\"]',\n                         'Thank you']);\n});\n\nbotmaster.use('outgoing', outgoingMiddleware.messageTransformers.updateText);\nbotmaster.use('outgoing', outgoingMiddleware.messageTransformers.addButtonsToMessage);\nbotmaster.use('outgoing', (bot, update, next) = {\n  const userId = message.recipient.id;\n\n  bot.sendIsTypingMessageTo(userId, { ignoreMiddleware: true })\n\n  .then(() = {\n    setTimeout(() = {\n      next();\n    }, 1000);\n  });\n})\n\nThere's a few things going on in this added bit of code here. First we make it clear again that middleware code can technically live anywhere. It would be better to have it in a separate file somewhere. But this also works. Second, We introduce the ignoreMiddleware option when sending a message. This will always work and simply tells Botmaster to not go through any of the middleware with this message and send it directly. This is very important as otherwise, we would be stuck in an infinite loop trying to send an \"is typing\" indicator. Second we note that we use setTimeout to make it look like the bot is typing for about 1 second before firing out the message by calling next().\n\n External middleware\n\nThis is all great. But Using the code in addButtonsToMessage to add buttons to your message is probably not the best. Indeed, external middleware packages provide better solutions to this problem. Like in any other framework that contains middleware, middleware can be put into packages. These packages are then available and downloadable via npm and thus easily accessible in your code.\n\nHave a look in our list of official middleware here\n",
        "tags": []
    },
    {
        "uri": "/content/working-with-botmaster/writing-your-own-bot-class",
        "title": "Writing your Own Bot Class",
        "content": "\nBot classes\n\nThe following document assumes that you have read the main documentation in \"getting started\" and in \"botmaster basics\". A general understand of how Botmaster and more generally how chatbots work is also assumed.\n\nBecause of that, we will pick up right from there and start looking into the bot classes Botmaster comes bundled with.\n\nBotmaster makes five usable bot classes available to developers out of the box. MessengerBot, SlackBot, SocketioBot, TelegramBot and TwitterBot.\n\nFor example, you can instantiate a new MessengerBot object as such:\n\nconst Botmaster = require('botmaster');\nconst MessengerBot = Botmaster.botTypes.MessengerBot;\n\nconst messengerSettings = {\n  credentials: {\n    verifyToken: 'YOUR verifyToken',\n    pageToken: 'YOUR pageToken',\n    fbAppSecret: 'YOUR fbAppSecret'\n  },\n  webhookEndpoint: '/webhook1234',\n};\n\nconst messengerBot = new MessengerBot(messengerSettings);\n\nIn order to get updates from Messenger, you would then be expected to mount your bot's express mini-app messengerBot.app onto your own express app by doing something like this:\n\nconst app = require('express')();\napp.use('/', messengerBot.app);\napp.listen(3001, function() {});\n\nOr even better:\n\nmessengerBot.app.listen(3001, function() {});\n\nThis will mount your bot onto: https://YourDomainName:3001/webhook1234. Note how the bot type is not part of the URL here.\n\n Making Botmaster objects and bot objects work together\n\nDoing this is really trivial and as it turns out, you do this every time you use the addBot method.\n\nWe recall from the various guides that to create a botmaster object the following is needed:\n\nconst Botmaster = require('botmaster');\nconst botmaster = new Botmaster();\n\nAs usual, we create a botmaster object. This one supports Twitter and Telegram, but not Messenger. We create it as such:\n\nIn this example the botmaster object will start a new express() app server running locally on port 3000 as expected by default (see here to see how to change that).\n\nAs usual, we add the messenegrBot as follows:\n\nbotmaster.addBot(messengerBot);\n\nThis will mount your bot onto: https://YourDomainName:3000/messenger/webhook1234. Note how the bot type is part of the endpoint here. This is because the Botmaster class assumes that you want your endpoint to be mounted onto its botType.\n\nYou will then get updates from the botmaster object as if you had instantiated it with the messenger settings too if your endpoint is setup properly.\n\n{{% notice info %}}\nPlease note, if you followed these steps and put all this code in one file. You will actually have two express servers running along side each other. One on port 3001 and one on port 3000. Both endpoints mentioned above would work. This is definitely not what you want to do in production. Pick one of the methods and stick to it in production.\n{{% /notice %}}\n\nThe main takeaway from all this is that any bot class that follows a  certain set of rules will be able to be added to a botmaster object.\n\nCreating your own bot classes\n\nBefore defining the rules that have to be respected in order to write a Botmaster compatible bot class let's look at the constructor of one of the existing one, TelegramBot:\n\n #constructor(settings)\n\nclass TelegramBot extends BaseBot {\n\n  constructor(settings) {\n    super(settings);\n    this.type = 'telegram';\n    this.requiresWebhook = true;\n    this.requiredCredentials = ['authToken'];\n\n    this.__applySettings(settings);\n    .\n    .\n    .\n    this.__createMountPoints();\n  }\n\n }\n\nLet's look into this line by line. The first line reads super(settings). Which of course just means it calls the constructor of TelegramBot's superclass, namely, BaseBot. BaseBot's constructor doesn't actually do anything fancy a part from calling its own superclass's constructor and setting a few default values [as pointers for you, the developer]. BaseBot calls its own superclass's constructor as it inherits from node.js's EventEmitter which will allow your bot's classes to listen to events as well as emit them.\n\nThe following three lines setup some important values.\n\n  this.type: the type of bot that is being instantiated. It's important to specify that as developers might want to condition some code on the type of bot you are writing.\n  this.requiresWebhook: whether the bot requires webhooks. If the platform you are coding for requires webhooks, you will be expected to set a this.app variable at some point in the setup. We'll look into this when we have a look at what the this.__createMountPoints(); does.\n  this.requiredCredentials: sets up an array of credentials that are expected to be defined for the platform you are coding your class for. Telegram only takes in 1, so we just have an array with the value 'authToken'.\n\n__applySettings(settings)\n\nThe next line calls the this.__applySettings(settings) function. This function is implemented in BaseBot and will just make sure that the settings passed on to the bot constructor are valid with respect to the parameters you defined. You should always call this function directly after setting the three [or more or less depending on your bot] parameters specific to the platform you are coding for. If valid, the settings will then be applied to the bot object. e.g. this.webhookEndpoint will be set to settings.webhookEndpoint.\n\n__createMountPoints()\n\nThe last line of our controller makes a call to this.__createMountPoints();. This line should only be present if your bot class requires webhooks. If this is the case, you will be expected to define a class member function that looks something like:\n\n  __createMountPoints() {\n    this.app = express();\n    // for parsing application/json\n    this.app.use(bodyParser.json());\n    // for parsing application/x-www-form-urlencoded\n    this.app.use(bodyParser.urlencoded({ extended: true }));\n\n    this.app.post(this.webhookEndpoint, (req, res) = {\n      this.__formatUpdate(req.body)\n\n      .then((update) = {\n        this.__emitUpdate(update);\n      }, (err) = {\n        err.message = Error in __formatUpdate \"${err.message}\". Please report this.;\n        this.emit('error', err);\n      });\n\n      // just letting telegram know we got the update\n      res.sendStatus(200);\n    });\n  }\n\nVery importantly, this function creates an express router this.app that will be mounted onto the main app router from the botmaster object if botmaster.addBot is used.\n\nIt then sets up the post endpoint that listens onto this.webhookEnpoint. No further assumption is made here.\n\nPlease note that you might have another function that needs to be called at this point. For instance, in the socketioBot class, I make a call to: this.__setupSocketioServer(); and that function looks like this:\n\n__setupSocketioServer() {\n  this.ioServer = io(this.server);\n\n  this.ioServer.on('connection', (socket) = {\n    socket.join(SocketioBot.__getBotmasteruserId(socket));\n\n    socket.on('message', (message) = {\n      // just broadcast the message to other connected clients with same user id\n      const botmasterUserId = SocketioBot.__getBotmasteruserId(socket);\n      socket.broadcast.to(botmasterUserId).emit('own message', message);\n      // console.log(JSON.stringify(socket.rooms, null, 2));\n      const rawUpdate = message;\n      try {\n        rawUpdate.socket = socket;\n      } catch (err) {\n        err.message = ERROR: \"Expected JSON object but got '${typeof message}' ${message} instead\";\n        return this.emit('error', err);\n      }\n      const update = this.__formatUpdate(rawUpdate, botmasterUserId);\n      return this.__emitUpdate(update);\n    });\n  });\n}\n\nFeel free to have a thorough read at this to understand what is going on here. Because it isn't necessary to understand this in order to build your own bot class, I won't explain what is going on here.\n\n__formatUpdate(rawUpdate)\n\nAlthough you can technically handle the body of the request as you wish. In our createMountPoints example here (from TelegramBot code), we make a call to the formatUpdate function with the body of the request.\nIt would make sense for you to do so for consistency and because it has to be defined if you want your bot class to eventually be referenced in the Botmaster project.\n\nThis function is expected to transform the rawUpdate into an object which is of the format of Messenger updates, while having an update.raw bit that references that rawUpdate received.\n\nTypically, it would look something like this for a message with an image attachment. Independent of what platform the message comes from:\n\n{\n  raw: platformspecificraw_update,\n  sender: {\n    id: idofsender\n  },\n  recipient: {\n    id: idofthe_recipent // will typically be the bot's id\n  },\n  timestamp: unixmilisecondstimestamp,\n  message: {\n    mid: message_id,\n    seq: messagesequenceid,\n    attachments: [\n      {\n        type: 'image',\n        payload: {\n          url: 'SOMEIMAGEURL'\n        }\n      }\n    ]\n  }\n};\n\nYour function should return the update object(or a promise that resolves a formatted update object) in order to then call __emitUpdate with it as a parameter.\n\n__emitUpdate(update)\n\nLike __applySettings, this method is implemented in BaseBot. It handles errors, calling the incoming middleware stack, and most importantly, actually calling this.emit(update) to emit the actual update. You can overwrite this method if you wish, but in its current state, it handles the most important cases you will want to deal with. You should call this method with the formatted update object created by calling formatUpdate();\n\n__sendMessage(message)\n\nAll previous methods had either something to do with object instantiation or with incoming messages. We'll now have a look at what needs to be done within your bot class to send messages.\n\nThe __sendMessage method needs to be implemented. The method should take in a Messenger style message and send a formatted message to the bot platform. It should return a Promise that resolves to something like this:\n\n  {\n   raw: rawBody,\n   recipientid: idof_user,\n   messageid: messageidofwhatwasjust_sent\n  }\n \n Code for it might look like this simplified one from TelegramBot:\n\n  __sendMessage(message) {\n  const options = {\n    url: 'https://api.telegram.org/sendMessage',\n    method: 'POST',\n  };\n  options.json = this.__formatOutgoingMessage(message);\n\n  return request(options) // using request-promise package and not request here\n\n  .then((body) = {\n    if (body.error) {\n      throw new Error(JSON.stringify(body.error));\n    }\n\n    const standardizedBody = {\n      raw: body,\n      recipient_id: body.result.chat.id,\n      // this is really the equivalent to a Messenger seq.\n      // But it's either that or null for telegram\n      messageid: body.result.messageid,\n    };\n    return standardizedBody;\n  });\n}\n \nSee how we are returning a promise that resolves to an object as specified above!\n\nIt is important to note that this be a promise and not a callback. Although developers using Botmaster can use sendMessage type methods with callbacks. The internals of Botmaster use Promises and therefore, so should your bot class.\n\nPlease note that the BaseBot superclass defines a set of methods that allow developers to more easily send messages to all platforms without having to build the whole Messenger compatible object themselves. These methods are the following:\n\nsendMessage\nsendMessageTo\nsendTextMessageTo\nreply\nsendAttachmentTo\nsendAttachmentFromURLTo\nsendDefaultButtonMessageTo\nsendIsTypingMessageTo\nsendCascadeTo\nsendTextCascadeTo\n\nAll these methods will convert a developer specified input into a Facebook Messenger compatible message that will be called as a parameter to sendMessage. That is, they all eventually will call your sendMessage method. You can however overwrite them if need be.\n\n__formatOutgoingMessage(message)\n\nYour sendMessage method is expected to call a __formatOutgoingMessage(message) method that will format the Messenger style message into one that is compatible with the platform you are coding your bot class for.\n\nYou can have a look at the ones defined in the TelegramBot and the TwitterBot classes for inspiration.\n\n__setBotIdIfNotSet(update)\n\nIn order to help you identify between bots of different types, you will want each bot instance to have a this.id value. This should typically be the same as update.recipient.id when getting updates. If these aren't set upon instantiation (as with Facebook Messenger bots), you can write a function like this MessengerBot one that gets called upon receiving a message.\n\n__setBotIdIfNotSet(update) {\n  if (!this.id) {\n  \tthis.id = update.recipient.id;\n  }\n}\n\nIs this really all there is to it?\n\nYes it is! These few basic steps are the steps that should be followed in order to build your own bot classes. Nothing more is required. Of course, formatting the incoming updates and the outgoing messages won't always be as trivial as we'd wish, but this guide should help you into doing this.\n",
        "tags": []
    }
]